<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>çˆ†ç‚¸å°é»„äºº - æˆ¿é—´ç‰ˆ</title>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body { background: #222; overflow: hidden; font-family: sans-serif; margin: 0; user-select: none; }

    .scene { perspective: 1000px; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    .table {
      width: 90vw; height: 60vh; max-width: 800px;
      background: #2c3e50; border: 8px solid #5d4037; border-radius: 20px;
      transform: rotateX(40deg) translateY(50px);
      transform-style: preserve-3d; position: relative;
      box-shadow: 0 50px 50px rgba(0,0,0,0.5);
    }

    .info-text {
      position: absolute; top: -72px; width: 100%;
      text-align: center; color: white;
      font-size: 18px; text-shadow: 0 2px 4px black;
      transform: translateZ(20px);
    }
    .pending-banner { margin-top: 6px; font-size: 13px; color: #ffca28; }

    .draw-pile {
      position: absolute; top: 50%; left: 50%;
      width: 100px; height: 140px;
      background: #ff9800;
      border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      font-size: 30px; color: white; font-weight: bold;
      cursor: pointer; box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      transition: 0.3s;
    }
    .my-turn-glow {
      box-shadow: 0 0 30px #00e676; border-color: #00e676;
      transform: translate(-50%, -50%) translateZ(20px) scale(1.1);
    }
    .draw-pile.is-bomb {
      background: #ff5252;
      border-color: #ff8a80;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateZ(20px) scale(1.15); }
      100% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
    }

    .discard-pile {
      position: absolute; top: 50%; left: 25%;
      width: 90px; height: 125px;
      background: #607d8b; border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      color: white; font-weight: bold;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      user-select: none;
    }
    .discard-pile .count { position: absolute; bottom: 10px; font-size: 12px; font-weight: normal; opacity: 0.95; }
    .discard-pile .topIcon { font-size: 34px; line-height: 1; }
    .discard-pile .topText { position: absolute; top: 8px; font-size: 12px; font-weight: normal; opacity: 0.95; }

    .my-hand {
      position: absolute; bottom: 30px; width: 100%;
      display: flex; justify-content: center; gap: 10px;
      transform: translateZ(50px);
      flex-wrap: wrap; padding: 0 10px;
    }

    .card {
      width: 70px; height: 100px; background: white; border-radius: 6px;
      display: flex; justify-content: center; align-items: center;
      font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 14px;
      transition: 0.2s;
      position: relative;
    }
    .card:hover { transform: translateY(-20px); }
    .card.defuse { background: #b9f6ca; color: #1b5e20; border: 2px solid #00c853; }
    .card.playable { border: 2px solid #00e676; box-shadow: 0 0 12px rgba(0, 230, 118, 0.7); cursor: pointer; }

    .badge {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 11px;
    }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white;
    }

    .slider-container { width: 80%; max-width: 400px; margin: 30px 0; text-align: center; }
    input[type=range] { width: 100%; height: 20px; accent-color: #ff9800; cursor: pointer; }

    .confirm-btn {
      padding: 15px 40px; font-size: 18px; background: #ff5252; color: white;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
      box-shadow: 0 0 20px #ff5252; margin-top: 20px;
    }
    .confirm-btn:active { transform: scale(0.95); }

    .checkbox-wrapper {
      margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px;
      background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 20px;
      border: 1px solid #ff5252;
    }
    input[type=checkbox] { width: 20px; height: 20px; accent-color: #ff5252; cursor: pointer;}

    .preview-row { display:flex; gap:12px; margin-top:20px; flex-wrap:wrap; justify-content:center; }
    .preview-card {
      width: 90px; height: 130px; border-radius: 10px;
      background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .preview-card .icon { font-size: 40px; margin-bottom: 10px; }
    .preview-card .name { font-size: 14px; opacity: 0.95; }

    .player-panel {
      position: fixed; top: 12px; right: 12px;
      width: 280px; max-height: 45vh; overflow: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 10px;
      color: #fff;
      z-index: 900;
      backdrop-filter: blur(6px);
    }
    .player-panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #ffca28;
      font-weight: 700;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .room-pill {
      font-size: 12px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 2px 8px;
      border-radius: 999px;
      color: #fff;
      font-weight: 800;
    }

    .player-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 8px; border-radius: 10px; margin-bottom: 6px;
      background: rgba(255,255,255,0.06);
    }
    .player-row.me { outline: 1px solid rgba(0,230,118,0.55); }
    .player-row.turn { box-shadow: 0 0 10px rgba(0,230,118,0.45); }
    .player-left { display: flex; flex-direction: column; gap: 2px; }
    .pid { font-size: 12px; opacity: 0.85; }
    .status { font-size: 12px; opacity: 0.9; }
    .handcount { font-size: 12px; opacity: 0.95; }

    .chat-panel {
      position: fixed; right: 12px; bottom: 12px;
      width: 320px; height: 260px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      z-index: 900;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    .chat-header {
      padding: 8px 10px;
      font-size: 14px;
      color: #ffca28;
      font-weight: 700;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-body {
      flex: 1;
      padding: 8px 10px;
      overflow: auto;
      font-size: 12px;
      color: #fff;
    }
    .chat-msg { margin-bottom: 8px; line-height: 1.35; }
    .chat-msg .meta { opacity: 0.75; margin-right: 6px; }
    .chat-msg.me .meta { color: #00e676; opacity: 0.95; }

    .chat-input {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.12);
      padding: 8px;
      gap: 8px;
      background: rgba(0,0,0,0.2);
    }
    .chat-input input {
      flex: 1;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 8px 10px;
      outline: none;
    }
    .chat-input button {
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      background: rgba(0,230,118,0.85);
      color: #0b1a12;
      font-weight: 800;
    }

    /* æŠ˜å èŠå¤©é¢æ¿ */
    .chat-panel.collapsed { height: 44px; }
    .chat-panel.collapsed .chat-body,
    .chat-panel.collapsed .chat-input { display: none; }
    .chat-toggle-btn {
      border: none;
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer;
      background: rgba(255,255,255,0.12);
      color: #fff;
      font-weight: 700;
    }

    /* æ‰‹æœºé€‚é…ï¼šç¼©å°é¢æ¿å ç”¨ */
    @media (max-width: 600px) {
      .chat-panel { width: 92vw; right: 4vw; bottom: 10px; height: 220px; }
      .player-panel { width: 92vw; right: 4vw; top: 10px; max-height: 26vh; }
    }

    /* Toast */
    .toast {
      position: fixed;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      z-index: 2000;
      min-width: 240px;
      max-width: 92vw;
      padding: 12px 16px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.65);
      color: #fff;
      font-weight: 800;
      font-size: 16px;
      text-align: center;
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      animation: toastIn 0.18s ease-out;
    }
    .toast.boom { background: rgba(255, 82, 82, 0.85); }
    .toast.defuse { background: rgba(0, 230, 118, 0.75); }
    .toast.info { background: rgba(255, 202, 40, 0.65); color: #1a1a1a; }
    @keyframes toastIn {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to   { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* å¤§å…è¾“å…¥æ¡† */
    .lobby-card {
      width: min(92vw, 520px);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 18px;
      padding: 18px 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }
    .lobby-title { font-size: 22px; font-weight: 900; margin: 0 0 10px 0; }
    .lobby-row { display:flex; gap:10px; margin-top: 10px; flex-wrap: wrap; }
    .lobby-input {
      flex: 1;
      min-width: 180px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 10px 12px;
      outline: none;
      font-size: 14px;
    }
    .lobby-btn {
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 900;
      background: rgba(0,230,118,0.9);
      color: #0b1a12;
      min-width: 120px;
    }
    .lobby-btn.secondary {
      background: rgba(255,255,255,0.14);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.18);
    }
    .lobby-hint { color: #ccc; font-size: 12px; margin-top: 8px; line-height: 1.5; }

    /* âœ… ç›®æ ‡é€‰æ‹©å¼¹çª— */
    .target-list {
      width: 90%;
      max-width: 520px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      margin-top: 14px;
    }
    .target-item {
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 12px 12px;
      border-radius: 12px;
      margin-bottom: 10px;
      background: rgba(0,0,0,0.25);
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.10);
    }
    .target-item:hover { border-color: rgba(0,230,118,0.70); }
    .target-item.disabled { opacity: 0.35; cursor: not-allowed; }
  </style>
</head>

<body>
<div id="app">

  <!-- Toast -->
  <div v-if="toast.show" class="toast" :class="toast.kind">
    {{ toast.text }}
  </div>

  <!-- å¤§å…ï¼šæ˜µç§° + åˆ›å»º/åŠ å…¥æˆ¿é—´ -->
  <div v-if="!inRoom" class="modal-overlay" style="background: rgba(0,0,0,0.88);">
    <div class="lobby-card">
      <div class="lobby-title">è¿›å…¥æˆ¿é—´</div>

      <div class="lobby-row">
        <input class="lobby-input" v-model="nameInput" placeholder="è¾“å…¥ä½ çš„æ˜µç§°ï¼ˆæœ€å¤š16å­—ï¼‰" />
      </div>

      <div class="lobby-row">
        <button class="lobby-btn" @click="createRoom">åˆ›å»ºæˆ¿é—´</button>
        <button class="lobby-btn secondary" @click="joinRoom">åŠ å…¥æˆ¿é—´</button>
      </div>

      <div class="lobby-row">
        <input class="lobby-input" v-model="roomInput" placeholder="æˆ¿é—´å·ï¼ˆå¦‚ ABCD2ï¼‰" style="text-transform:uppercase;" />
      </div>

      <div class="lobby-hint">
        è§„åˆ™ï¼šæˆ¿é—´ä»…åœ¨æœåŠ¡å™¨è¿è¡ŒæœŸé—´æœ‰æ•ˆï¼›åˆ·æ–°é¡µé¢éœ€è¦é‡æ–°åŠ å…¥æˆ¿é—´ã€‚<br />
        åŠ å…¥æˆ¿é—´åï¼Œè‡³å°‘ 2 äººå³å¯è‡ªåŠ¨å¼€å§‹æ–°å±€ã€‚
      </div>

      <div v-if="lobbyError" class="lobby-hint" style="color:#ff8a80; font-weight:800;">
        {{ lobbyError }}
      </div>
    </div>
  </div>

  <!-- âœ… æˆå¯¹ç‰Œï¼šé€‰æ‹©ç›®æ ‡å¼¹çª— -->
  <div v-if="isChoosingTarget" class="modal-overlay" style="background: rgba(0,0,0,0.92);">
    <h1 style="margin:0;">ğŸ­ ä¸¤å¼ ã€{{ pairCardToPlay }}ã€‘</h1>
    <p style="color:#ccc; margin-top:10px;">é€‰æ‹©ä¸€ä¸ªç›®æ ‡ç©å®¶ï¼ŒéšæœºæŠ½å–ä»– 1 å¼ ç‰Œï¼ˆä¸å…¬å¼€å¯¹æ–¹æ‰‹ç‰Œï¼‰ã€‚</p>

    <div class="target-list">
      <div
        class="target-item"
        v-for="p in stealTargets"
        :key="p.id"
        :class="{ disabled: p.isDead }"
        @click="selectTarget(p)"
      >
        <div style="display:flex; flex-direction:column; gap:4px;">
          <div style="font-weight:900;">
            {{ p.name || shortId(p.id) }}
            <span v-if="p.id === currentTurnId" style="color:#00e676; margin-left:8px; font-weight:800;">å½“å‰å›åˆ</span>
          </div>
          <div style="font-size:12px; opacity:0.8;">
            {{ p.isDead ? 'å·²æ­»äº¡' : 'å­˜æ´»' }}
          </div>
        </div>

        <div style="opacity:0.9; font-weight:800;">
          æ‰‹ç‰Œï¼š{{ p.handCount }}
        </div>
      </div>

      <div v-if="stealTargets.length === 0" style="color:#ccc; padding: 10px 6px;">
        å½“å‰æ²¡æœ‰å¯é€‰æ‹©çš„ç›®æ ‡ã€‚
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#607d8b; box-shadow:none;"
            @click="cancelChooseTarget">
      å–æ¶ˆ
    </button>
  </div>

  <!-- ç©å®¶åˆ—è¡¨ -->
  <div class="player-panel" v-if="inRoom">
    <h3>
      <span>ç©å®¶åˆ—è¡¨ï¼ˆæ‰‹ç‰Œæ•°ï¼‰</span>
      <span class="room-pill">æˆ¿é—´ï¼š{{ roomId }}</span>
    </h3>

    <div
      class="player-row"
      v-for="p in otherPlayersSorted"
      :key="p.id"
      :class="{
        'me': p.id === myId,
        'turn': p.id === currentTurnId
      }"
    >
      <div class="player-left">
        <div class="pid">
          {{ p.name || shortId(p.id) }}
          <span v-if="p.id === myId">(ä½ )</span>
        </div>
        <div class="status">
          <span v-if="p.isDead" style="color:#ff5252;">å·²æ­»äº¡</span>
          <span v-else style="color:#00e676;">å­˜æ´»</span>
        </div>
      </div>
      <div class="handcount">æ‰‹ç‰Œï¼š{{ p.handCount }}</div>
    </div>
  </div>

  <!-- èŠå¤©åŒºï¼ˆå¯æŠ˜å ï¼‰ -->
  <div class="chat-panel" :class="{ collapsed: chatCollapsed }" v-if="inRoom">
    <div class="chat-header">
      <div>èŠå¤©</div>
      <div style="display:flex; align-items:center; gap:8px;">
        <div style="font-size:12px; opacity:0.75;">åœ¨çº¿ï¼š{{ playerCount }}</div>
        <button class="chat-toggle-btn" @click="toggleChat">
          {{ chatCollapsed ? 'å±•å¼€' : 'æ”¶èµ·' }}
        </button>
      </div>
    </div>

    <div class="chat-body" ref="chatBody">
      <div
        class="chat-msg"
        v-for="(m, idx) in chatMessages"
        :key="idx"
        :class="{ 'me': m.id === myId }"
      >
        <span class="meta">[{{ timeText(m.ts) }}] {{ m.name || shortId(m.id) }}:</span>
        <span>{{ m.text }}</span>
      </div>
    </div>

    <div class="chat-input">
      <input
        v-model="chatInput"
        placeholder="è¾“å…¥æ¶ˆæ¯ï¼Œå›è½¦å‘é€..."
        @keydown.enter.prevent="sendChat"
      />
      <button @click="sendChat">å‘é€</button>
    </div>
  </div>

  <!-- ç»“ç®—å¼¹çª— -->
  <div v-if="isGameOver" class="modal-overlay" style="background: rgba(44, 62, 80, 0.98);">
    <div style="font-size: 80px; margin-bottom: 20px;">
      {{ isWinner ? 'ğŸ†' : 'ğŸ’€' }}
    </div>

    <h1 style="font-size: 40px; margin: 0;">
      {{ isWinner ? 'ä½ èµ¢äº†ï¼' : 'æ¸¸æˆç»“æŸ' }}
    </h1>

    <p style="font-size: 20px; color: #ccc; margin-top: 10px;">
      {{ winReasonText }}
    </p>

    <button class="confirm-btn"
            style="background: #00e676; box-shadow: 0 0 20px #00e676;"
            @click="requestRestart">
      ğŸ”„ å†æ¥ä¸€å±€
    </button>
  </div>

  <!-- æ­»äº¡å¼¹çª— -->
  <div v-if="amIDead && !isGameOver" class="modal-overlay" style="background: rgba(50,0,0,0.95);">
    <h1 style="font-size: 50px; color: red;">YOU DIED</h1>
    <p>ä½ ç‚¸äº†ã€‚</p>
    <p style="color:#ccc; margin-top:10px;">ç­‰å¾…æœ¬å±€ç»“æŸ...</p>
  </div>

  <!-- é¢„çŸ¥å¼¹çª— -->
  <div v-if="isPreviewing" class="modal-overlay" style="background: rgba(0, 0, 0, 0.92);">
    <h1 style="margin:0;">ğŸ‘ï¸ é¢„çŸ¥ï¼šç‰Œé¡¶ä¸‰å¼ </h1>
    <p style="color:#ccc; margin-top:10px;">ä»…ä½ å¯è§ã€‚é¡ºåºä¸ºï¼šä»ç‰Œé¡¶åˆ°æ›´ä¸‹é¢ã€‚</p>

    <div class="preview-row">
      <div class="preview-card" v-for="(c, idx) in previewCards" :key="idx">
        <div class="icon">{{ cardIcon(c) }}</div>
        <div class="name">{{ c }}</div>
      </div>
      <div v-if="previewCards.length === 0" style="color:#ccc; margin-top:10px;">
        ç‰Œåº“ä¸è¶³ä¸‰å¼ 
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#00e676; box-shadow:0 0 20px #00e676;"
            @click="closePreview">
      çŸ¥é“äº†
    </button>
  </div>

  <!-- æ‹†å¼¹å¼¹çª— -->
  <div v-if="isDefusing" class="modal-overlay">
    <h1>âš ï¸ ç‚¸å¼¹æ‹†é™¤æˆåŠŸï¼</h1>
    <p>å†³å®šè¦æŠŠç‚¸å¼¹å¡å›å“ªé‡Œ...</p>

    <div class="slider-container">
      <input type="range" v-model="insertIndex" min="0" :max="deckMaxIndex" step="1">

      <div style="display: flex; justify-content: space-between; margin-top: 10px; color: #aaa;">
        <span>ç‰Œåº• (å®‰å…¨)</span>
        <span style="color: #ff9800; font-weight: bold;">{{ insertPositionText }}</span>
        <span>ç‰Œé¡¶ (å±é™©)</span>
      </div>

      <div class="checkbox-wrapper" v-if="parseInt(insertIndex) === deckMaxIndex">
        <input type="checkbox" id="publicBomb" v-model="isPublicInsert">
        <label for="publicBomb" style="cursor: pointer; font-weight: bold;">â˜ ï¸ æ˜ç‰Œæ”¾ç½® (å…¬å¼€å¤„åˆ‘)</label>
      </div>

      <div v-else style="margin-top: 20px; font-size: 12px; color: #666; height: 42px;">
        æš—ç‰ŒåŸ‹è—ä¸­...
      </div>
    </div>

    <button class="confirm-btn" @click="confirmInsert">ç¡®å®šåŸ‹è—</button>
  </div>

  <div class="scene" v-if="inRoom">
    <div class="table">

      <div class="info-text">
        <div v-if="phase === 'waiting'" style="color:#ffca28;">
          ğŸŸ¡ ç­‰å¾…ç©å®¶åŠ å…¥ï¼ˆè‡³å°‘ 2 äººï¼‰
        </div>
        <div v-else-if="phase === 'ended'" style="color:#ffca28;">
          ğŸŸ£ æœ¬å±€å·²ç»“æŸ
        </div>
        <div v-else-if="amIDead">å·²æ­»äº¡</div>
        <div v-else-if="isMyTurnServer" style="color:#00e676">
          ğŸŸ¢ è½®åˆ°ä½ äº†ï¼ˆå‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>
        <div v-else>
          ğŸ”´ ç­‰å¾…å¯¹æ‰‹...ï¼ˆå½“å‰ç©å®¶å‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>

        <div class="pending-banner" v-if="pendingAction">
          â³ å¾…ç»“ç®—ï¼š{{ pendingActionText }} ï½œé˜»æ­¢æ¬¡æ•°ï¼š{{ pendingAction.nopeCount }} ï½œå‰©ä½™ï¼š{{ pendingMsLeft }}ms
        </div>

        <div v-if="lastActionMsg" style="font-size:14px; color: #ffca28; margin-top:5px;">
          {{ lastActionMsg }}
        </div>
      </div>

      <!-- å¼ƒç‰Œå † -->
      <div class="discard-pile" :title="discardTopCard ? ('é¡¶ç‰Œï¼š' + discardTopCard) : 'å¼ƒç‰Œå †ä¸ºç©º'">
        <div class="topText">å¼ƒç‰Œå †</div>
        <div class="topIcon">{{ cardIcon(discardTopCard) }}</div>
        <div class="count">æ•°é‡ï¼š{{ discardCount }}</div>
      </div>

      <!-- ç‰Œåº“ -->
      <div
        class="draw-pile"
        :class="{
          'my-turn-glow': isMyTurnServer && !isDefusing && !isGameOver && phase === 'playing',
          'is-bomb': topCardPublic === 'ç‚¸å¼¹'
        }"
        @click="drawCard"
      >
        {{ topCardPublic === 'ç‚¸å¼¹' ? 'â˜ ï¸' : deckCount }}
        <div style="font-size: 12px; position: absolute; bottom: 10px; font-weight: normal;">
          {{ topCardPublic === 'ç‚¸å¼¹' ? 'ä¸‹å¼ å¿…æ­»' : 'ç‚¹å‡»æŠ½ç‰Œ' }}
        </div>
      </div>

      <!-- æ‰‹ç‰Œ -->
      <div class="my-hand">
        <div
          v-for="(card, i) in myHand"
          :key="i"
          class="card"
          :class="{
            'defuse': card === 'æ‹†é™¤',
            'playable': isCardPlayable(card)
          }"
          @click="onCardClick(card)"
          :title="cardHelp(card)"
        >
          {{ card }}
          <div class="badge" v-if="cardCount(card) >= 2 && characterCards.includes(card)">
            Ã—{{ cardCount(card) }}
          </div>
        </div>
      </div>

    </div>
  </div>

</div>

<script>
  const { createApp, ref, computed, onMounted, onUnmounted, nextTick } = Vue;
  const socket = io();

  createApp({
    setup() {
      // æˆ¿é—´/å¤§å…
      const inRoom = ref(false);
      const roomId = ref('');
      const nameInput = ref('');
      const roomInput = ref('');
      const lobbyError = ref('');

      // æ¸¸æˆçŠ¶æ€
      const myId = ref('');
      const myName = ref('');

      const myHand = ref([]);
      const currentTurnId = ref(null);
      const deckCount = ref(0);

      const phase = ref('waiting');
      const topCardPublic = ref(null);

      const discardCount = ref(0);
      const discardTopCard = ref(null);

      const turnsLeftForCurrent = ref(0);

      const pendingAction = ref(null);
      const pendingMsLeft = ref(0);
      let msTimer = null;

      const isDefusing = ref(false);
      const insertIndex = ref(0);
      const deckMaxIndex = ref(0);
      const isPublicInsert = ref(false);

      const amIDead = ref(false);

      const isGameOver = ref(false);
      const isWinner = ref(false);
      const winReasonText = ref('');

      const lastActionMsg = ref('');

      const isPreviewing = ref(false);
      const previewCards = ref([]);

      // ç©å®¶å…¬å…±ä¿¡æ¯
      const playersPublic = ref({});

      // èŠå¤©
      const chatMessages = ref([]);
      const chatInput = ref('');
      const chatBody = ref(null);

      // èŠå¤©æŠ˜å ï¼ˆæ‰‹æœºé»˜è®¤æŠ˜å ï¼‰
      const chatCollapsed = ref(false);
      const toggleChat = () => {
        chatCollapsed.value = !chatCollapsed.value;
        if (!chatCollapsed.value) autoScrollChat();
      };
      function applyChatDefaultByWidth() {
        chatCollapsed.value = window.innerWidth <= 600;
      }
      let onResize = null;

      // Toast
      const toast = ref({ show: false, text: '', kind: 'info' });
      let toastTimer = null;
      const showToast = (kind, text, ms = 2200) => {
        toast.value = { show: true, kind, text };
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => { toast.value.show = false; }, ms);
      };

      // è§’è‰²ç‰Œ
      const characterCards = ['æµ·ç»µçˆ¸çˆ¸', 'æ´¾å°æ˜Ÿ', 'ç« é±¼å¼Ÿ'];
      const activeTurnCards = ['è·³è¿‡', 'æ”»å‡»', 'é¢„çŸ¥', 'å…‹éš†ç‰Œ', 'åº•æŠ½', 'æ´—æ··'];
      const nopeCard = 'é˜»æ­¢';

      // âœ… æˆå¯¹ç‰Œï¼šç›®æ ‡é€‰æ‹©å¼¹çª—çŠ¶æ€
      const isChoosingTarget = ref(false);
      const pairCardToPlay = ref(null);

      // æœåŠ¡ç«¯ä¸‹å‘æ˜¯å¦è½®åˆ°æˆ‘
      const isMyTurnServer = ref(false);

      const shortId = (id) => id ? id.slice(0, 6) : '';
      const timeText = (ts) => {
        const d = new Date(ts || Date.now());
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        const ss = String(d.getSeconds()).padStart(2, '0');
        return `${hh}:${mm}:${ss}`;
      };

      const cardIcon = (card) => {
        switch (card) {
          case 'ç‚¸å¼¹': return 'â˜ ï¸';
          case 'æ‹†é™¤': return 'ğŸ›¡';
          case 'è·³è¿‡': return 'â­';
          case 'æ”»å‡»': return 'âš”ï¸';
          case 'é¢„çŸ¥': return 'ğŸ‘ï¸';
          case 'å…‹éš†ç‰Œ': return 'ğŸ§¬';
          case 'é˜»æ­¢': return 'âœ‹';
          case 'åº•æŠ½': return 'â¬‡ï¸';
          case 'æ´—æ··': return 'ğŸ”€';
          case 'æµ·ç»µçˆ¸çˆ¸': return 'ğŸ§½';
          case 'æ´¾å°æ˜Ÿ': return 'â­';
          case 'ç« é±¼å¼Ÿ': return 'ğŸ™';
          default: return 'â€”';
        }
      };

      const cardHelp = (card) => {
        if (card === 'è·³è¿‡') return 'è·³è¿‡ï¼šç»“æŸæœ¬å›åˆï¼ˆä¸æŠ½ç‰Œï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ”»å‡»') return 'æ”»å‡»ï¼šç»“æŸå½“å‰å›åˆå¹¶è®©ä¸‹å®¶æ€»å…± 2 å›åˆï¼ˆå¯å åŠ ï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é¢„çŸ¥') return 'é¢„çŸ¥ï¼šæŸ¥çœ‹ç‰Œé¡¶ä¸‰å¼ ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'å…‹éš†ç‰Œ') return 'å…‹éš†ç‰Œï¼šå…‹éš†å¼ƒç‰Œå †é¡¶ç‰Œæ•ˆæœï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é˜»æ­¢') return 'é˜»æ­¢ï¼šå¯åœ¨éè‡ªå·±å›åˆä½¿ç”¨ï¼Œä½¿å¾…ç»“ç®—åŠ¨ä½œå¤±æ•ˆï¼ˆé˜»æ­¢å¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'åº•æŠ½') return 'åº•æŠ½ï¼šä»ç‰Œåº•æŠ½ 1 å¼ å¹¶ç»“æŸå›åˆï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ´—æ··') return 'æ´—æ··ï¼šæ´—æ··å‰©ä½™ç‰Œå †ï¼Œå¹¶å…³é—­æ˜ç‰Œï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (characterCards.includes(card)) return 'è§’è‰²ç‰Œï¼šä¸¤å¼ åŒåå¯ä¸€èµ·æ‰“å‡ºï¼ŒéšæœºæŠ½å–ç›®æ ‡ 1 å¼ ç‰Œï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        return '';
      };

      const countMap = computed(() => {
        const m = {};
        for (const c of myHand.value) m[c] = (m[c] || 0) + 1;
        return m;
      });
      const cardCount = (card) => countMap.value[card] || 0;

      const playerCount = computed(() => Object.keys(playersPublic.value || {}).length);

      const otherPlayersSorted = computed(() => {
        const arr = Object.values(playersPublic.value || {});
        arr.sort((a, b) => {
          const aTurn = a.id === currentTurnId.value ? 1 : 0;
          const bTurn = b.id === currentTurnId.value ? 1 : 0;
          if (aTurn !== bTurn) return bTurn - aTurn;

          const aMe = a.id === myId.value ? 1 : 0;
          const bMe = b.id === myId.value ? 1 : 0;
          if (aMe !== bMe) return bMe - aMe;

          const aAlive = a.isDead ? 0 : 1;
          const bAlive = b.isDead ? 0 : 1;
          if (aAlive !== bAlive) return bAlive - aAlive;

          return (a.name || a.id).localeCompare(b.name || b.id);
        });
        return arr;
      });

      const canPlayTurnCard = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && isMyTurnServer.value
          && !isDefusing.value
          && !pendingAction.value
          && !isChoosingTarget.value;
      });

      const canPlayPairNow = computed(() => {
        return phase.value === 'playing'
            && !isGameOver.value
            && !amIDead.value
            && isMyTurnServer.value
            && !isDefusing.value
            && !pendingAction.value;
        });

      const canPlayNope = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && !isDefusing.value
          && !!pendingAction.value
          && myHand.value.includes(nopeCard);
      });

      const pendingActionText = computed(() => {
        if (!pendingAction.value) return '';
        return `${pendingAction.value.displayCard}`;
      });

      // âœ… å¯å·ç›®æ ‡åˆ—è¡¨ï¼ˆæ’é™¤è‡ªå·±ï¼‰
      const stealTargets = computed(() => {
        return Object.values(playersPublic.value || {}).filter(p => p.id !== myId.value);
      });

      function tickMsLeft() {
        if (!pendingAction.value || !pendingAction.value.resolveAt) {
          pendingMsLeft.value = 0;
          return;
        }
        pendingMsLeft.value = Math.max(0, Math.floor(pendingAction.value.resolveAt - Date.now()));
      }

      function autoScrollChat() {
        nextTick(() => {
          if (!chatBody.value) return;
          chatBody.value.scrollTop = chatBody.value.scrollHeight;
        });
      }

      function applyEnded(wid) {
        isGameOver.value = true;
        if (wid === null || wid === undefined) {
          isWinner.value = false;
          winReasonText.value = "â˜ ï¸ æ— äººå¹¸å­˜ï¼ˆåŒå½’äºå°½ï¼‰";
        } else if (wid === myId.value) {
          isWinner.value = true;
          winReasonText.value = "ğŸ‰ æ­å–œï¼ä½ æ˜¯æœ€åçš„å¹¸å­˜è€…ï¼";
        } else {
          isWinner.value = false;
          winReasonText.value = "ğŸ‘» ä½ è¢«æ·˜æ±°äº†ï¼Œèƒœè€…æ˜¯åˆ«äººã€‚";
        }
      }

      // ---- æˆ¿é—´åŠ¨ä½œ ----
      const createRoom = () => {
        lobbyError.value = '';
        socket.emit('createRoom', { name: nameInput.value });
      };
      const joinRoom = () => {
        lobbyError.value = '';
        socket.emit('joinRoom', { roomId: roomInput.value, name: nameInput.value });
      };

      // ---- socket ----
      socket.on('connect', () => {
        myId.value = socket.id;
      });

      socket.on('roomCreated', (data) => {
        if (data?.roomId) {
          roomId.value = data.roomId;
          roomInput.value = data.roomId;
          showToast('info', `âœ… å·²åˆ›å»ºæˆ¿é—´ï¼š${data.roomId}`, 1600);
        }
      });

      socket.on('roomJoined', (data) => {
        inRoom.value = true;
        lobbyError.value = '';
        roomId.value = data.roomId || roomId.value;
        myName.value = data.name || myName.value;
        showToast('info', `è¿›å…¥æˆ¿é—´ï¼š${roomId.value}`, 1200);
        socket.emit('requestState');
      });

      socket.on('roomLeft', () => {
        inRoom.value = false;
        roomId.value = '';
        myName.value = '';
        playersPublic.value = {};
        myHand.value = [];
        chatMessages.value = [];
        showToast('info', 'å·²ç¦»å¼€æˆ¿é—´', 1200);
      });

      socket.on('roomError', (data) => {
        lobbyError.value = data?.message || 'æ“ä½œå¤±è´¥';
        showToast('boom', lobbyError.value, 2200);
      });

      socket.on('gameState', (data) => {
        if (!data) return;

        if (data.roomId) roomId.value = data.roomId;
        if (data.youId) myId.value = data.youId;
        if (data.youName !== undefined) myName.value = data.youName;

        isMyTurnServer.value = !!data.isMyTurn;

        playersPublic.value = data.players || {};
        myHand.value = data.myHand || [];

        deckCount.value = data.deckCount ?? 0;
        currentTurnId.value = data.currentTurn ?? null;
        topCardPublic.value = data.topCardPublic ?? null;

        phase.value = data.phase || 'waiting';

        discardCount.value = data.discardCount ?? 0;
        discardTopCard.value = data.discardTopCard ?? null;

        turnsLeftForCurrent.value = data.turnsLeftForCurrent ?? 0;

        pendingAction.value = data.pendingAction ?? null;

        amIDead.value = !!playersPublic.value?.[myId.value]?.isDead;

        if (Array.isArray(data.chatHistory)) {
          chatMessages.value = data.chatHistory;
          autoScrollChat();
        }

        if (phase.value === 'ended') applyEnded(data.winnerId);
        else {
          isGameOver.value = false;
          isWinner.value = false;
          winReasonText.value = '';
        }

        // å¦‚æœä¸å†æ»¡è¶³å‡ºç‰Œæ¡ä»¶ï¼Œè‡ªåŠ¨å…³é—­â€œé€‰ç›®æ ‡å¼¹çª—â€ï¼ˆé˜²æ­¢å¡ä½ï¼‰
        if (isChoosingTarget.value && !canPlayPairNow.value) {
          isChoosingTarget.value = false;
          pairCardToPlay.value = null;
        }
      });

      socket.on('chatMessage', (m) => {
        if (!m || !m.text) return;
        chatMessages.value.push(m);
        if (chatMessages.value.length > 200) chatMessages.value = chatMessages.value.slice(-200);
        autoScrollChat();
      });

      socket.on('askInsertBomb', (data) => {
        isDefusing.value = true;
        deckMaxIndex.value = data.maxIndex;
        insertIndex.value = data.maxIndex;
        isPublicInsert.value = false;

        // æ‹†å¼¹ä¸­ä¸å…è®¸é€‰ç›®æ ‡
        isChoosingTarget.value = false;
        pairCardToPlay.value = null;
      });

      socket.on('previewCards', (data) => {
        previewCards.value = (data && data.cards) ? data.cards : [];
        isPreviewing.value = true;
      });

      socket.on('cardPlayed', (data) => {
        if (!data) return;
        const actorName = playersPublic.value?.[data.id]?.name || shortId(data.id);
        const actor = (data.id === myId.value) ? 'ä½ ' : actorName;
        lastActionMsg.value = `ğŸƒ ${actor} ä½¿ç”¨ã€${data.card}ã€‘`;
      });

      socket.on('nopePlayed', (data) => {
        if (!data) return;
        const actorName = playersPublic.value?.[data.id]?.name || shortId(data.id);
        const actor = (data.id === myId.value) ? 'ä½ ' : actorName;
        lastActionMsg.value = `âœ‹ ${actor} æ‰“å‡ºäº†ã€é˜»æ­¢ã€‘ï¼ˆæ¬¡æ•°ï¼š${data.nopeCount}ï¼‰`;
      });

      socket.on('actionResolved', (data) => {
        if (!data) return;
        if (data.cancelled) lastActionMsg.value = `ğŸš« åŠ¨ä½œå¤±æ•ˆï¼š${data.reason || 'å·²è¢«é˜»æ­¢'}`;
        else lastActionMsg.value = `âœ… åŠ¨ä½œç”Ÿæ•ˆ`;
      });

      socket.on('pairSteal', (data) => {
        if (!data) return;
        const actorName = playersPublic.value?.[data.actorId]?.name || shortId(data.actorId);
        const targetName = playersPublic.value?.[data.targetId]?.name || shortId(data.targetId);

        const actor = data.actorId === myId.value ? 'ä½ ' : actorName;
        const target = data.targetId === myId.value ? 'ä½ ' : targetName;

        if (!data.success) {
          lastActionMsg.value = `ğŸ­ ${actor} æŠ½å–å¤±è´¥ï¼š${data.reason || 'æœªçŸ¥åŸå› '}`;
          return;
        }
        lastActionMsg.value = `ğŸ­ ${actor} ä» ${target} æŠ½èµ°äº†ä¸€å¼ ç‰Œ`;
      });

      socket.on('stolenCard', (data) => {
        if (!data || !data.card) return;
        lastActionMsg.value = `ğŸ ä½ æŠ½åˆ°çš„ç‰Œæ˜¯ï¼šã€${data.card}ã€‘`;
      });

      socket.on('stolenFromYou', (data) => {
        const whoId = data?.by;
        const who = playersPublic.value?.[whoId]?.name || shortId(whoId) || 'æŸäºº';
        lastActionMsg.value = `ğŸ˜µ ä½ è¢« ${who} æŠ½èµ°äº†ä¸€å¼ ç‰Œ`;
      });

      socket.on('bombDrawn', (data) => {
        if (!data?.id) return;
        const actorName = playersPublic.value?.[data.id]?.name || shortId(data.id);
        if (data.id === myId.value) {
          showToast('boom', 'â˜ ï¸ ä½ æŠ½åˆ°äº†ç‚¸å¼¹ï¼', 2200);
          lastActionMsg.value = 'â˜ ï¸ ä½ æŠ½åˆ°äº†ç‚¸å¼¹ï¼';
        } else {
          showToast('boom', `â˜ ï¸ ${actorName} æŠ½åˆ°äº†ç‚¸å¼¹ï¼`, 2200);
          lastActionMsg.value = `â˜ ï¸ ${actorName} æŠ½åˆ°äº†ç‚¸å¼¹ï¼`;
        }
      });

      socket.on('bombDefused', (data) => {
        if (!data?.id) return;
        const via = data.via || 'æ‹†é™¤';
        const actorName = playersPublic.value?.[data.id]?.name || shortId(data.id);
        if (data.id === myId.value) showToast('defuse', `ğŸ›¡ ä½ æ‹†é™¤äº†ç‚¸å¼¹ï¼ˆ${via}ï¼‰`, 2200);
        else showToast('defuse', `ğŸ›¡ ${actorName} æ‹†é™¤äº†ç‚¸å¼¹ï¼ˆ${via}ï¼‰`, 2200);
      });

      socket.on('playerDied', (data) => {
        if (!data?.id) return;
        const actorName = playersPublic.value?.[data.id]?.name || shortId(data.id);
        if (data.id === myId.value) showToast('boom', 'ğŸ’¥ ä½ çˆ†ç‚¸äº†ï¼', 2600);
        else showToast('boom', `ğŸ’¥ ${actorName} çˆ†ç‚¸äº†ï¼`, 2600);
      });

      socket.on('bombInserted', () => {
        showToast('info', 'ğŸ‘€ ç‚¸å¼¹å·²è¢«å¡å›ç‰Œå †', 1600);
        lastActionMsg.value = "ğŸ‘€ ç‚¸å¼¹å·²è¢«åŸ‹å›...";
      });

      socket.on('gameOver', (data) => applyEnded(data.winnerId));

      socket.on('gameRestarted', () => {
        isGameOver.value = false;
        isWinner.value = false;
        winReasonText.value = '';

        isDefusing.value = false;
        insertIndex.value = 0;
        topCardPublic.value = null;

        isPreviewing.value = false;
        previewCards.value = [];

        pendingAction.value = null;
        pendingMsLeft.value = 0;

        // âœ… æ–°å±€å¼€å§‹å…³é—­ç›®æ ‡å¼¹çª—
        isChoosingTarget.value = false;
        pairCardToPlay.value = null;

        lastActionMsg.value = "=== æ–°æ¸¸æˆå¼€å§‹ ===";
        socket.emit('requestState');
      });

      socket.on('errorMsg', (data) => {
        if (data && data.message) lastActionMsg.value = "âš ï¸ " + data.message;
      });

      onMounted(() => {
        msTimer = setInterval(tickMsLeft, 100);
        applyChatDefaultByWidth();
        onResize = () => applyChatDefaultByWidth();
        window.addEventListener('resize', onResize);
        autoScrollChat();
      });

      onUnmounted(() => {
        if (msTimer) clearInterval(msTimer);
        if (onResize) window.removeEventListener('resize', onResize);
        if (toastTimer) clearTimeout(toastTimer);
      });

      // ---- æ¸¸æˆäº¤äº’ ----
      const insertPositionText = computed(() => {
        const idx = parseInt(insertIndex.value);
        if (idx === deckMaxIndex.value) return "ç‰Œé¡¶ (æœ€å±é™©)";
        if (idx === 0) return "ç‰Œåº• (æœ€å®‰å…¨)";
        return `ç¬¬ ${idx + 1} å¼ `;
      });

      const drawCard = () => {
        if (phase.value !== 'playing') return;
        if (pendingAction.value) {
          lastActionMsg.value = "âš ï¸ æœ‰å¾…ç»“ç®—åŠ¨ä½œï¼Œå…ˆç­‰ç»“ç®—/ä½¿ç”¨é˜»æ­¢";
          return;
        }
        if (isMyTurnServer.value && !isDefusing.value && !isChoosingTarget.value) socket.emit('drawCard');
      };

      const isCardPlayable = (card) => {
        if (card === 'é˜»æ­¢') return canPlayNope.value;
        if (activeTurnCards.includes(card)) return canPlayTurnCard.value;
        if (characterCards.includes(card)) return canPlayPairNow.value && (cardCount(card) >= 2);
        return false;
      };

      const cancelChooseTarget = () => {
        isChoosingTarget.value = false;
        pairCardToPlay.value = null;
      };

      const selectTarget = (p) => {
        if (!p) return;
        if (p.id === myId.value) return;        // ä¸ä¼šå‡ºç°ï¼Œä½†å†ä¿é™©
        if (p.isDead) return;                   // ç¦æ­¢é€‰æ­»äºº
        if (!pairCardToPlay.value) return;

        // å¦‚æœåœ¨ç‚¹å‡»æœŸé—´çŠ¶æ€å˜äº†ï¼Œé¿å…é”™è¯¯
        if (!canPlayPairNow.value) {
          showToast('boom', 'å½“å‰ä¸èƒ½å‡ºç‰Œï¼ˆçŠ¶æ€å·²å˜åŒ–ï¼‰', 1600);
          cancelChooseTarget();
          return;
        }

        const cc = pairCardToPlay.value;
        cancelChooseTarget();
        socket.emit('playPair', { card: cc, targetId: p.id });
      };

      const onCardClick = (card) => {
        if (card === 'é˜»æ­¢') {
          if (!canPlayNope.value) {
            lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½ä½¿ç”¨é˜»æ­¢";
            return;
          }
          socket.emit('playNope');
          return;
        }

        // âœ… è§’è‰²ç‰Œï¼šä¸¤å¼ åŒå -> æ‰“å¼€ç›®æ ‡é€‰æ‹©å¼¹çª—
        if (characterCards.includes(card)) {
          if (!isCardPlayable(card)) {
            lastActionMsg.value = "âš ï¸ è§’è‰²ç‰Œéœ€è¦ä¸¤å¼ åŒåï¼Œä¸”å¿…é¡»åœ¨ä½ å›åˆä½¿ç”¨";
            return;
          }

          if (stealTargets.value.length === 0) {
            showToast('info', 'æ²¡æœ‰å¯é€‰æ‹©çš„ç›®æ ‡', 1600);
            return;
          }

          pairCardToPlay.value = card;
          isChoosingTarget.value = true;
          return;
        }

        if (!activeTurnCards.includes(card)) return;

        if (!canPlayTurnCard.value) {
          lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½å‡ºç‰Œï¼ˆéä½ å›åˆ/æ‹†å¼¹ä¸­/æœ‰å¾…ç»“ç®—åŠ¨ä½œ/å·²ç»“æŸï¼‰";
          return;
        }

        socket.emit('playCard', { card });
      };

      const confirmInsert = () => {
        isDefusing.value = false;
        socket.emit('insertBomb', { index: parseInt(insertIndex.value), isPublic: isPublicInsert.value });
      };

      const requestRestart = () => socket.emit('restartGame');

      const closePreview = () => {
        isPreviewing.value = false;
        previewCards.value = [];
      };

      const sendChat = () => {
        const txt = (chatInput.value || '').trim();
        if (!txt) return;
        socket.emit('sendChat', { text: txt });
        chatInput.value = '';
      };

      return {
        // lobby
        inRoom, roomId, nameInput, roomInput, lobbyError, createRoom, joinRoom,

        // state
        myId, myName, myHand, currentTurnId, deckCount, phase, topCardPublic,
        discardCount, discardTopCard, turnsLeftForCurrent,
        pendingAction, pendingMsLeft,
        isDefusing, insertIndex, deckMaxIndex, isPublicInsert, insertPositionText,
        amIDead, isGameOver, isWinner, winReasonText, lastActionMsg,
        isPreviewing, previewCards,
        playersPublic, playerCount, otherPlayersSorted, shortId, timeText,
        chatMessages, chatInput, sendChat, chatBody,
        cardIcon, cardHelp, isCardPlayable, onCardClick,
        characterCards, cardCount,
        drawCard, confirmInsert, requestRestart, closePreview,
        pendingActionText, isMyTurnServer,
        chatCollapsed, toggleChat,
        toast,

        // âœ… target modal
        isChoosingTarget, pairCardToPlay, stealTargets, selectTarget, cancelChooseTarget
      };
    }
  }).mount('#app');
</script>
</body>
</html>
