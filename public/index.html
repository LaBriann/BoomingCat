<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>çˆ†ç‚¸å°é»„äºº - å®Œæ•´ç‰ˆ</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body { background: #222; overflow: hidden; font-family: sans-serif; margin: 0; user-select: none; }

    .scene { perspective: 1000px; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    .table {
      width: 90vw; height: 60vh; max-width: 800px;
      background: #2c3e50; border: 8px solid #5d4037; border-radius: 20px;
      transform: rotateX(40deg) translateY(50px);
      transform-style: preserve-3d; position: relative;
      box-shadow: 0 50px 50px rgba(0,0,0,0.5);
    }

    .info-text {
      position: absolute; top: -72px; width: 100%;
      text-align: center; color: white;
      font-size: 18px; text-shadow: 0 2px 4px black;
      transform: translateZ(20px);
    }
    .pending-banner { margin-top: 6px; font-size: 13px; color: #ffca28; }

    .draw-pile {
      position: absolute; top: 50%; left: 50%;
      width: 100px; height: 140px;
      background: #ff9800;
      border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      font-size: 30px; color: white; font-weight: bold;
      cursor: pointer; box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      transition: 0.3s;
    }
    .my-turn-glow {
      box-shadow: 0 0 30px #00e676; border-color: #00e676;
      transform: translate(-50%, -50%) translateZ(20px) scale(1.1);
    }
    .draw-pile.is-bomb {
      background: #ff5252;
      border-color: #ff8a80;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateZ(20px) scale(1.15); }
      100% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
    }

    .discard-pile {
      position: absolute; top: 50%; left: 25%;
      width: 90px; height: 125px;
      background: #607d8b; border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      color: white; font-weight: bold;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      user-select: none;
    }
    .discard-pile .count { position: absolute; bottom: 10px; font-size: 12px; font-weight: normal; opacity: 0.95; }
    .discard-pile .topIcon { font-size: 34px; line-height: 1; }
    .discard-pile .topText { position: absolute; top: 8px; font-size: 12px; font-weight: normal; opacity: 0.95; }

    .my-hand {
      position: absolute; bottom: 30px; width: 100%;
      display: flex; justify-content: center; gap: 10px;
      transform: translateZ(50px);
      flex-wrap: wrap; padding: 0 10px;
    }

    .card {
      width: 70px; height: 100px; background: white; border-radius: 6px;
      display: flex; justify-content: center; align-items: center;
      font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 14px;
      transition: 0.2s;
      position: relative;
    }
    .card:hover { transform: translateY(-20px); }
    .card.defuse { background: #b9f6ca; color: #1b5e20; border: 2px solid #00c853; }
    .card.playable { border: 2px solid #00e676; box-shadow: 0 0 12px rgba(0, 230, 118, 0.7); cursor: pointer; }

    .badge {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 11px;
    }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white;
    }

    .slider-container { width: 80%; max-width: 400px; margin: 30px 0; text-align: center; }
    input[type=range] { width: 100%; height: 20px; accent-color: #ff9800; cursor: pointer; }

    .confirm-btn {
      padding: 15px 40px; font-size: 18px; background: #ff5252; color: white;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
      box-shadow: 0 0 20px #ff5252; margin-top: 20px;
    }
    .confirm-btn:active { transform: scale(0.95); }

    .checkbox-wrapper {
      margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px;
      background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 20px;
      border: 1px solid #ff5252;
    }
    input[type=checkbox] { width: 20px; height: 20px; accent-color: #ff5252; cursor: pointer;}

    .preview-row { display:flex; gap:12px; margin-top:20px; flex-wrap:wrap; justify-content:center; }
    .preview-card {
      width: 90px; height: 130px; border-radius: 10px;
      background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .preview-card .icon { font-size: 40px; margin-bottom: 10px; }
    .preview-card .name { font-size: 14px; opacity: 0.95; }

    .player-panel {
      position: fixed; top: 12px; right: 12px;
      width: 260px; max-height: 45vh; overflow: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 10px;
      color: #fff;
      z-index: 900;
      backdrop-filter: blur(6px);
    }
    .player-panel h3 { margin: 0 0 8px 0; font-size: 14px; color: #ffca28; font-weight: 700; }
    .player-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 8px; border-radius: 10px; margin-bottom: 6px;
      background: rgba(255,255,255,0.06);
    }
    .player-row.me { outline: 1px solid rgba(0,230,118,0.55); }
    .player-row.turn { box-shadow: 0 0 10px rgba(0,230,118,0.45); }
    .player-left { display: flex; flex-direction: column; gap: 2px; }
    .pid { font-size: 12px; opacity: 0.85; }
    .status { font-size: 12px; opacity: 0.9; }
    .handcount { font-size: 12px; opacity: 0.95; }

    .chat-panel {
      position: fixed; right: 12px; bottom: 12px;
      width: 320px; height: 260px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      z-index: 900;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    .chat-header {
      padding: 8px 10px;
      font-size: 14px;
      color: #ffca28;
      font-weight: 700;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .chat-body {
      flex: 1;
      padding: 8px 10px;
      overflow: auto;
      font-size: 12px;
      color: #fff;
    }
    .chat-msg { margin-bottom: 8px; line-height: 1.35; }
    .chat-msg .meta { opacity: 0.75; margin-right: 6px; }
    .chat-msg.me .meta { color: #00e676; opacity: 0.95; }
    .chat-input {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.12);
      padding: 8px;
      gap: 8px;
      background: rgba(0,0,0,0.2);
    }
    .chat-input input {
      flex: 1;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 8px 10px;
      outline: none;
    }
    .chat-input button {
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      background: rgba(0,230,118,0.85);
      color: #0b1a12;
      font-weight: 800;
    }
    .chat-input button:active { transform: scale(0.98); }

    .target-list {
      width: 90%;
      max-width: 420px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      margin-top: 14px;
    }
    .target-item {
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      border-radius: 12px;
      margin-bottom: 10px;
      background: rgba(0,0,0,0.25);
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .target-item:hover { border-color: rgba(0,230,118,0.6); }
    .target-item.disabled { opacity: 0.35; cursor: not-allowed; }
  </style>
</head>

<body>
<div id="app">

  <!-- ç©å®¶åˆ—è¡¨ -->
  <div class="player-panel">
    <h3>ç©å®¶åˆ—è¡¨ï¼ˆæ‰‹ç‰Œæ•°ï¼‰</h3>
    <div
      class="player-row"
      v-for="p in otherPlayersSorted"
      :key="p.id"
      :class="{
        'me': p.id === myId,
        'turn': p.id === currentTurnId
      }"
    >
      <div class="player-left">
        <div class="pid">{{ shortId(p.id) }} <span v-if="p.id === myId">(ä½ )</span></div>
        <div class="status">
          <span v-if="p.isDead" style="color:#ff5252;">å·²æ­»äº¡</span>
          <span v-else style="color:#00e676;">å­˜æ´»</span>
        </div>
      </div>
      <div class="handcount">æ‰‹ç‰Œï¼š{{ p.handCount }}</div>
    </div>
  </div>

  <!-- èŠå¤©åŒº -->
  <div class="chat-panel">
    <div class="chat-header">
      <div>èŠå¤©</div>
      <div style="font-size:12px; opacity:0.75;">åœ¨çº¿ï¼š{{ playerCount }}</div>
    </div>
    <div class="chat-body" ref="chatBody">
      <div
        class="chat-msg"
        v-for="(m, idx) in chatMessages"
        :key="idx"
        :class="{ 'me': m.id === myId }"
      >
        <span class="meta">[{{ timeText(m.ts) }}] {{ shortId(m.id) }}:</span>
        <span>{{ m.text }}</span>
      </div>
    </div>
    <div class="chat-input">
      <input
        v-model="chatInput"
        placeholder="è¾“å…¥æ¶ˆæ¯ï¼Œå›è½¦å‘é€..."
        @keydown.enter.prevent="sendChat"
      />
      <button @click="sendChat">å‘é€</button>
    </div>
  </div>

  <!-- é€‰æ‹©ç›®æ ‡ç©å®¶ Modalï¼ˆè§’è‰²ç‰Œä¸¤å¼ æˆå¯¹ï¼‰ -->
  <div v-if="isChoosingTarget" class="modal-overlay" style="background: rgba(0,0,0,0.92);">
    <h1 style="margin:0;">ğŸ­ ä¸¤å¼ ã€{{ pairCardToPlay }}ã€‘</h1>
    <p style="color:#ccc; margin-top:10px;">é€‰æ‹©ä¸€ä¸ªç›®æ ‡ç©å®¶ï¼ŒéšæœºæŠ½ä»– 1 å¼ ç‰Œï¼ˆä¸å…¬å¼€å¯¹æ–¹æ‰‹ç‰Œï¼‰ã€‚</p>

    <div class="target-list">
      <div
        class="target-item"
        v-for="p in stealTargets"
        :key="p.id"
        :class="{ disabled: p.isDead }"
        @click="selectTarget(p)"
      >
        <div>
          {{ shortId(p.id) }}
          <span v-if="p.id === currentTurnId" style="color:#00e676; margin-left:6px;">å½“å‰å›åˆ</span>
        </div>
        <div style="opacity:0.9;">æ‰‹ç‰Œï¼š{{ p.handCount }}</div>
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#607d8b; box-shadow:none;"
            @click="cancelChooseTarget">
      å–æ¶ˆ
    </button>
  </div>

  <!-- ç»“ç®—å¼¹çª— -->
  <div v-if="isGameOver" class="modal-overlay" style="background: rgba(44, 62, 80, 0.98);">
    <div style="font-size: 80px; margin-bottom: 20px;">
      {{ isWinner ? 'ğŸ†' : 'ğŸ’€' }}
    </div>

    <h1 style="font-size: 40px; margin: 0;">
      {{ isWinner ? 'ä½ èµ¢äº†ï¼' : 'æ¸¸æˆç»“æŸ' }}
    </h1>

    <p style="font-size: 20px; color: #ccc; margin-top: 10px;">
      {{ winReasonText }}
    </p>

    <button class="confirm-btn"
            style="background: #00e676; box-shadow: 0 0 20px #00e676;"
            @click="requestRestart">
      ğŸ”„ å†æ¥ä¸€å±€
    </button>
  </div>

  <!-- æ­»äº¡å¼¹çª— -->
  <div v-if="amIDead && !isGameOver" class="modal-overlay" style="background: rgba(50,0,0,0.95);">
    <h1 style="font-size: 50px; color: red;">YOU DIED</h1>
    <p>ä½ ç‚¸äº†ã€‚</p>
    <p style="color:#ccc; margin-top:10px;">ç­‰å¾…æœ¬å±€ç»“æŸ...</p>
  </div>

  <!-- é¢„çŸ¥å¼¹çª— -->
  <div v-if="isPreviewing" class="modal-overlay" style="background: rgba(0, 0, 0, 0.92);">
    <h1 style="margin:0;">ğŸ‘ï¸ é¢„çŸ¥ï¼šç‰Œé¡¶ä¸‰å¼ </h1>
    <p style="color:#ccc; margin-top:10px;">ä»…ä½ å¯è§ã€‚é¡ºåºä¸ºï¼šä»ç‰Œé¡¶åˆ°æ›´ä¸‹é¢ã€‚</p>

    <div class="preview-row">
      <div class="preview-card" v-for="(c, idx) in previewCards" :key="idx">
        <div class="icon">{{ cardIcon(c) }}</div>
        <div class="name">{{ c }}</div>
      </div>
      <div v-if="previewCards.length === 0" style="color:#ccc; margin-top:10px;">
        ç‰Œåº“ä¸è¶³ä¸‰å¼ 
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#00e676; box-shadow:0 0 20px #00e676;"
            @click="closePreview">
      çŸ¥é“äº†
    </button>
  </div>

  <!-- æ‹†å¼¹å¼¹çª— -->
  <div v-if="isDefusing" class="modal-overlay">
    <h1>âš ï¸ ç‚¸å¼¹æ‹†é™¤æˆåŠŸï¼</h1>
    <p>å†³å®šè¦æŠŠç‚¸å¼¹å¡å›å“ªé‡Œ...</p>

    <div class="slider-container">
      <input type="range" v-model="insertIndex" min="0" :max="deckMaxIndex" step="1">

      <div style="display: flex; justify-content: space-between; margin-top: 10px; color: #aaa;">
        <span>ç‰Œåº• (å®‰å…¨)</span>
        <span style="color: #ff9800; font-weight: bold;">{{ insertPositionText }}</span>
        <span>ç‰Œé¡¶ (å±é™©)</span>
      </div>

      <div class="checkbox-wrapper" v-if="parseInt(insertIndex) === deckMaxIndex">
        <input type="checkbox" id="publicBomb" v-model="isPublicInsert">
        <label for="publicBomb" style="cursor: pointer; font-weight: bold;">â˜ ï¸ æ˜ç‰Œæ”¾ç½® (å…¬å¼€å¤„åˆ‘)</label>
      </div>

      <div v-else style="margin-top: 20px; font-size: 12px; color: #666; height: 42px;">
        æš—ç‰ŒåŸ‹è—ä¸­...
      </div>
    </div>

    <button class="confirm-btn" @click="confirmInsert">ç¡®å®šåŸ‹è—</button>
  </div>

  <div class="scene">
    <div class="table">

      <div class="info-text">
        <div v-if="phase === 'waiting'" style="color:#ffca28;">
          ğŸŸ¡ ç­‰å¾…ç©å®¶åŠ å…¥ï¼ˆè‡³å°‘ 2 äººï¼‰
        </div>
        <div v-else-if="phase === 'ended'" style="color:#ffca28;">
          ğŸŸ£ æœ¬å±€å·²ç»“æŸ
        </div>
        <div v-else-if="amIDead">å·²æ­»äº¡</div>
        <div v-else-if="isMyTurnServer" style="color:#00e676">
          ğŸŸ¢ è½®åˆ°ä½ äº†ï¼ˆå‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>
        <div v-else>
          ğŸ”´ ç­‰å¾…å¯¹æ‰‹...ï¼ˆå½“å‰ç©å®¶å‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>

        <div class="pending-banner" v-if="pendingAction">
          â³ å¾…ç»“ç®—ï¼š{{ pendingActionText }} ï½œé˜»æ­¢æ¬¡æ•°ï¼š{{ pendingAction.nopeCount }} ï½œå‰©ä½™ï¼š{{ pendingMsLeft }}ms
        </div>

        <div v-if="lastActionMsg" style="font-size:14px; color: #ffca28; margin-top:5px;">
          {{ lastActionMsg }}
        </div>
      </div>

      <!-- å¼ƒç‰Œå † -->
      <div class="discard-pile" :title="discardTopCard ? ('é¡¶ç‰Œï¼š' + discardTopCard) : 'å¼ƒç‰Œå †ä¸ºç©º'">
        <div class="topText">å¼ƒç‰Œå †</div>
        <div class="topIcon">{{ cardIcon(discardTopCard) }}</div>
        <div class="count">æ•°é‡ï¼š{{ discardCount }}</div>
      </div>

      <!-- ç‰Œåº“ -->
      <div
        class="draw-pile"
        :class="{
          'my-turn-glow': isMyTurnServer && !isDefusing && !isGameOver && phase === 'playing',
          'is-bomb': topCardPublic === 'ç‚¸å¼¹'
        }"
        @click="drawCard"
      >
        {{ topCardPublic === 'ç‚¸å¼¹' ? 'â˜ ï¸' : deckCount }}
        <div style="font-size: 12px; position: absolute; bottom: 10px; font-weight: normal;">
          {{ topCardPublic === 'ç‚¸å¼¹' ? 'ä¸‹å¼ å¿…æ­»' : 'ç‚¹å‡»æŠ½ç‰Œ' }}
        </div>
      </div>

      <!-- æ‰‹ç‰Œ -->
      <div class="my-hand">
        <div
          v-for="(card, i) in myHand"
          :key="i"
          class="card"
          :class="{
            'defuse': card === 'æ‹†é™¤',
            'playable': isCardPlayable(card)
          }"
          @click="onCardClick(card)"
          :title="cardHelp(card)"
        >
          {{ card }}
          <div class="badge" v-if="cardCount(card) >= 2 && characterCards.includes(card)">
            Ã—{{ cardCount(card) }}
          </div>
        </div>
      </div>

    </div>
  </div>

</div>

<script>
  const { createApp, ref, computed, onMounted, onUnmounted, nextTick } = Vue;
  const socket = io();

  createApp({
    setup() {
      const myId = ref('');
      const myHand = ref([]);
      const currentTurnId = ref(null);
      const deckCount = ref(0);

      const phase = ref('waiting');
      const topCardPublic = ref(null);

      const discardCount = ref(0);
      const discardTopCard = ref(null);

      const turnsLeftForCurrent = ref(0);

      const pendingAction = ref(null);
      const pendingMsLeft = ref(0);
      let msTimer = null;

      const isDefusing = ref(false);
      const insertIndex = ref(0);
      const deckMaxIndex = ref(0);
      const isPublicInsert = ref(false);

      const amIDead = ref(false);

      const isGameOver = ref(false);
      const isWinner = ref(false);
      const winReasonText = ref('');

      const lastActionMsg = ref('');

      const isPreviewing = ref(false);
      const previewCards = ref([]);

      // ç©å®¶å…¬å…±ä¿¡æ¯ï¼ˆåªå« handCountï¼‰
      const playersPublic = ref({});

      // èŠå¤©
      const chatMessages = ref([]);
      const chatInput = ref('');
      const chatBody = ref(null);

      // è§’è‰²ç‰Œ
      const characterCards = ['æµ·ç»µçˆ¸çˆ¸', 'æ´¾å°æ˜Ÿ', 'ç« é±¼å¼Ÿ'];

      // é€‰æ‹©ç›®æ ‡ï¼ˆæˆå¯¹å‡ºç‰Œï¼‰
      const isChoosingTarget = ref(false);
      const pairCardToPlay = ref(null);

      // ä¸»åŠ¨ç‰Œ
      const activeTurnCards = ['è·³è¿‡', 'æ”»å‡»', 'é¢„çŸ¥', 'å…‹éš†ç‰Œ', 'åº•æŠ½', 'æ´—æ··'];
      const nopeCard = 'é˜»æ­¢';

      // å…³é”®ä¿®å¤ï¼šç”±æœåŠ¡ç«¯ä¸‹å‘æ˜¯å¦è½®åˆ°æˆ‘
      const isMyTurnServer = ref(false);

      const shortId = (id) => id ? id.slice(0, 6) : '';
      const timeText = (ts) => {
        const d = new Date(ts || Date.now());
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        const ss = String(d.getSeconds()).padStart(2, '0');
        return `${hh}:${mm}:${ss}`;
      };

      const cardIcon = (card) => {
        switch (card) {
          case 'ç‚¸å¼¹': return 'â˜ ï¸';
          case 'æ‹†é™¤': return 'ğŸ›¡';
          case 'è·³è¿‡': return 'â­';
          case 'æ”»å‡»': return 'âš”ï¸';
          case 'é¢„çŸ¥': return 'ğŸ‘ï¸';
          case 'å…‹éš†ç‰Œ': return 'ğŸ§¬';
          case 'é˜»æ­¢': return 'âœ‹';
          case 'åº•æŠ½': return 'â¬‡ï¸';
          case 'æ´—æ··': return 'ğŸ”€';
          case 'æµ·ç»µçˆ¸çˆ¸': return 'ğŸ§½';
          case 'æ´¾å°æ˜Ÿ': return 'â­';
          case 'ç« é±¼å¼Ÿ': return 'ğŸ™';
          default: return 'â€”';
        }
      };

      const cardHelp = (card) => {
        if (card === 'è·³è¿‡') return 'è·³è¿‡ï¼šç»“æŸæœ¬å›åˆï¼ˆä¸æŠ½ç‰Œï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ”»å‡»') return 'æ”»å‡»ï¼šç»“æŸå½“å‰å›åˆå¹¶è®©ä¸‹å®¶æ€»å…± 2 å›åˆï¼ˆå¯å åŠ ï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é¢„çŸ¥') return 'é¢„çŸ¥ï¼šæŸ¥çœ‹ç‰Œé¡¶ä¸‰å¼ ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'å…‹éš†ç‰Œ') return 'å…‹éš†ç‰Œï¼šå…‹éš†å¼ƒç‰Œå †é¡¶ç‰Œæ•ˆæœï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é˜»æ­¢') return 'é˜»æ­¢ï¼šå¯åœ¨éè‡ªå·±å›åˆä½¿ç”¨ï¼Œä½¿å¾…ç»“ç®—åŠ¨ä½œå¤±æ•ˆï¼ˆé˜»æ­¢å¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'åº•æŠ½') return 'åº•æŠ½ï¼šä»ç‰Œåº•æŠ½ 1 å¼ å¹¶ç»“æŸå›åˆï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ´—æ··') return 'æ´—æ··ï¼šæ´—æ··å‰©ä½™ç‰Œå †ï¼Œå¹¶å…³é—­æ˜ç‰Œï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (characterCards.includes(card)) return 'è§’è‰²ç‰Œï¼šä¸¤å¼ åŒåå¯ä¸€èµ·æ‰“å‡ºï¼ŒéšæœºæŠ½å–ç›®æ ‡ 1 å¼ ç‰Œï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        return '';
      };

      const countMap = computed(() => {
        const m = {};
        for (const c of myHand.value) m[c] = (m[c] || 0) + 1;
        return m;
      });

      const cardCount = (card) => countMap.value[card] || 0;

      const playerCount = computed(() => Object.keys(playersPublic.value || {}).length);

      const otherPlayersSorted = computed(() => {
        const arr = Object.values(playersPublic.value || {});
        arr.sort((a, b) => {
          const aTurn = a.id === currentTurnId.value ? 1 : 0;
          const bTurn = b.id === currentTurnId.value ? 1 : 0;
          if (aTurn !== bTurn) return bTurn - aTurn;

          const aMe = a.id === myId.value ? 1 : 0;
          const bMe = b.id === myId.value ? 1 : 0;
          if (aMe !== bMe) return bMe - aMe;

          const aAlive = a.isDead ? 0 : 1;
          const bAlive = b.isDead ? 0 : 1;
          if (aAlive !== bAlive) return bAlive - aAlive;

          return a.id.localeCompare(b.id);
        });
        return arr;
      });

      const canPlayTurnCard = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && isMyTurnServer.value
          && !isDefusing.value
          && !pendingAction.value
          && !isChoosingTarget.value;
      });

      const canPlayNope = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && !isDefusing.value
          && !!pendingAction.value
          && myHand.value.includes(nopeCard);
      });

      const pendingActionText = computed(() => {
        if (!pendingAction.value) return '';
        const pa = pendingAction.value;
        return `${pa.displayCard}`;
      });

      function tickMsLeft() {
        if (!pendingAction.value || !pendingAction.value.resolveAt) {
          pendingMsLeft.value = 0;
          return;
        }
        pendingMsLeft.value = Math.max(0, Math.floor(pendingAction.value.resolveAt - Date.now()));
      }

      function autoScrollChat() {
        nextTick(() => {
          if (!chatBody.value) return;
          chatBody.value.scrollTop = chatBody.value.scrollHeight;
        });
      }

      function applyEnded(wid) {
        isGameOver.value = true;
        if (wid === null || wid === undefined) {
          isWinner.value = false;
          winReasonText.value = "â˜ ï¸ æ— äººå¹¸å­˜ï¼ˆåŒå½’äºå°½ï¼‰";
        } else if (wid === myId.value) {
          isWinner.value = true;
          winReasonText.value = "ğŸ‰ æ­å–œï¼ä½ æ˜¯æœ€åçš„å¹¸å­˜è€…ï¼";
        } else {
          isWinner.value = false;
          winReasonText.value = "ğŸ‘» ä½ è¢«æ·˜æ±°äº†ï¼Œèƒœè€…æ˜¯åˆ«äººã€‚";
        }
      }

      // --- Socket ç›‘å¬ ---
      socket.on('connect', () => {
        // è¿™é‡Œä¿ç•™ï¼Œä½†æœ€ç»ˆä»¥ gameState.youId ä¸ºå‡†
        myId.value = socket.id;
        socket.emit('requestState');
      });

      socket.on('gameState', (data) => {
        // å…œåº•ï¼šä»¥æœåŠ¡ç«¯ç»™çš„ youId ä¸ºå‡†ï¼ˆè§£å†³æ—¶åº/é‡è¿ï¼‰
        if (data.youId) myId.value = data.youId;

        // å…³é”®ï¼šç”±æœåŠ¡ç«¯ä¸‹å‘
        isMyTurnServer.value = !!data.isMyTurn;

        playersPublic.value = data.players || {};
        myHand.value = data.myHand || [];

        deckCount.value = data.deckCount;
        currentTurnId.value = data.currentTurn;
        topCardPublic.value = data.topCardPublic;

        phase.value = data.phase || 'waiting';

        discardCount.value = data.discardCount ?? 0;
        discardTopCard.value = data.discardTopCard ?? null;

        turnsLeftForCurrent.value = data.turnsLeftForCurrent ?? 0;

        pendingAction.value = data.pendingAction ?? null;

        amIDead.value = !!playersPublic.value?.[myId.value]?.isDead;

        if (Array.isArray(data.chatHistory)) {
          chatMessages.value = data.chatHistory;
          autoScrollChat();
        }

        if (phase.value === 'ended') applyEnded(data.winnerId);
        else {
          isGameOver.value = false;
          isWinner.value = false;
          winReasonText.value = '';
        }
      });

      socket.on('chatMessage', (m) => {
        if (!m || !m.text) return;
        chatMessages.value.push(m);
        if (chatMessages.value.length > 200) chatMessages.value = chatMessages.value.slice(-200);
        autoScrollChat();
      });

      socket.on('askInsertBomb', (data) => {
        isDefusing.value = true;
        deckMaxIndex.value = data.maxIndex;
        insertIndex.value = data.maxIndex;
        isPublicInsert.value = false;
      });

      socket.on('previewCards', (data) => {
        previewCards.value = (data && data.cards) ? data.cards : [];
        isPreviewing.value = true;
      });

      socket.on('cardPlayed', (data) => {
        if (!data) return;
        const actor = (data.id === myId.value) ? 'ä½ ' : 'å¯¹æ‰‹';
        lastActionMsg.value = `ğŸƒ ${actor} ä½¿ç”¨ã€${data.card}ã€‘`;
      });

      socket.on('nopePlayed', (data) => {
        if (!data) return;
        const actor = (data.id === myId.value) ? 'ä½ ' : 'å¯¹æ‰‹';
        lastActionMsg.value = `âœ‹ ${actor} æ‰“å‡ºäº†ã€é˜»æ­¢ã€‘ï¼ˆæ¬¡æ•°ï¼š${data.nopeCount}ï¼‰`;
      });

      socket.on('actionResolved', (data) => {
        if (!data) return;
        if (data.cancelled) lastActionMsg.value = `ğŸš« åŠ¨ä½œå¤±æ•ˆï¼š${data.reason || 'å·²è¢«é˜»æ­¢'}`;
        else lastActionMsg.value = `âœ… åŠ¨ä½œç”Ÿæ•ˆ`;
      });

      socket.on('pairSteal', (data) => {
        if (!data) return;
        const actor = data.actorId === myId.value ? 'ä½ ' : shortId(data.actorId);
        const target = data.targetId === myId.value ? 'ä½ ' : shortId(data.targetId);

        if (!data.success) {
          lastActionMsg.value = `ğŸ­ ${actor} å°è¯•ä» ${target} æŠ½å–å¤±è´¥ï¼š${data.reason || 'æœªçŸ¥åŸå› '}`;
          return;
        }
        lastActionMsg.value = `ğŸ­ ${actor} ä» ${target} æŠ½èµ°äº†ä¸€å¼ ç‰Œ`;
      });

      socket.on('stolenCard', (data) => {
        if (!data || !data.card) return;
        lastActionMsg.value = `ğŸ ä½ æŠ½åˆ°çš„ç‰Œæ˜¯ï¼šã€${data.card}ã€‘`;
      });

      socket.on('stolenFromYou', (data) => {
        const who = data?.by ? shortId(data.by) : 'æŸäºº';
        lastActionMsg.value = `ğŸ˜µ ä½ è¢« ${who} æŠ½èµ°äº†ä¸€å¼ ç‰Œ`;
      });

      socket.on('gameOver', (data) => applyEnded(data.winnerId));

      socket.on('gameRestarted', () => {
        isGameOver.value = false;
        isWinner.value = false;
        winReasonText.value = '';

        isDefusing.value = false;
        insertIndex.value = 0;
        topCardPublic.value = null;

        isPreviewing.value = false;
        previewCards.value = [];

        pendingAction.value = null;
        pendingMsLeft.value = 0;

        isChoosingTarget.value = false;
        pairCardToPlay.value = null;

        lastActionMsg.value = "=== æ–°æ¸¸æˆå¼€å§‹ ===";
        socket.emit('requestState');
      });

      socket.on('errorMsg', (data) => {
        if (data && data.message) lastActionMsg.value = "âš ï¸ " + data.message;
      });

      onMounted(() => {
        msTimer = setInterval(tickMsLeft, 100);
        autoScrollChat();
      });
      onUnmounted(() => {
        if (msTimer) clearInterval(msTimer);
      });

      // --- äº¤äº’ ---
      const insertPositionText = computed(() => {
        const idx = parseInt(insertIndex.value);
        if (idx === deckMaxIndex.value) return "ç‰Œé¡¶ (æœ€å±é™©)";
        if (idx === 0) return "ç‰Œåº• (æœ€å®‰å…¨)";
        return `ç¬¬ ${idx + 1} å¼ `;
      });

      const drawCard = () => {
        if (phase.value !== 'playing') return;
        if (pendingAction.value) {
          lastActionMsg.value = "âš ï¸ æœ‰å¾…ç»“ç®—åŠ¨ä½œï¼Œå…ˆç­‰ç»“ç®—/ä½¿ç”¨é˜»æ­¢";
          return;
        }
        if (isMyTurnServer.value && !isDefusing.value && !isChoosingTarget.value) {
          socket.emit('drawCard');
        }
      };

      const isCardPlayable = (card) => {
        if (card === 'é˜»æ­¢') return canPlayNope.value;
        if (activeTurnCards.includes(card)) return canPlayTurnCard.value;
        if (characterCards.includes(card)) return canPlayTurnCard.value && (cardCount(card) >= 2);
        return false;
      };

      const onCardClick = (card) => {
        if (card === 'é˜»æ­¢') {
          if (!canPlayNope.value) {
            lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½ä½¿ç”¨é˜»æ­¢";
            return;
          }
          socket.emit('playNope');
          return;
        }

        if (characterCards.includes(card)) {
          if (!isCardPlayable(card)) {
            lastActionMsg.value = "âš ï¸ è§’è‰²ç‰Œéœ€è¦ä¸¤å¼ åŒåï¼Œä¸”å¿…é¡»åœ¨ä½ å›åˆä½¿ç”¨";
            return;
          }
          pairCardToPlay.value = card;
          isChoosingTarget.value = true;
          return;
        }

        if (!activeTurnCards.includes(card)) return;

        if (!canPlayTurnCard.value) {
          lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½å‡ºç‰Œï¼ˆéä½ å›åˆ/æ‹†å¼¹ä¸­/æœ‰å¾…ç»“ç®—åŠ¨ä½œ/å·²ç»“æŸï¼‰";
          return;
        }

        socket.emit('playCard', { card });
      };

      const confirmInsert = () => {
        isDefusing.value = false;
        socket.emit('insertBomb', { index: parseInt(insertIndex.value), isPublic: isPublicInsert.value });
      };

      const requestRestart = () => socket.emit('restartGame');

      const closePreview = () => {
        isPreviewing.value = false;
        previewCards.value = [];
      };

      const sendChat = () => {
        const txt = (chatInput.value || '').trim();
        if (!txt) return;
        socket.emit('sendChat', { text: txt });
        chatInput.value = '';
      };

      const stealTargets = computed(() => {
        return Object.values(playersPublic.value || {}).filter(p => p.id !== myId.value);
      });

      const selectTarget = (p) => {
        if (!p || p.id === myId.value) return;
        if (p.isDead) {
          lastActionMsg.value = "âš ï¸ ç›®æ ‡å·²æ­»äº¡ï¼Œä¸èƒ½é€‰æ‹©";
          return;
        }
        socket.emit('playPair', { card: pairCardToPlay.value, targetId: p.id });
        isChoosingTarget.value = false;
        pairCardToPlay.value = null;
      };

      const cancelChooseTarget = () => {
        isChoosingTarget.value = false;
        pairCardToPlay.value = null;
      };

      return {
        myId, myHand, currentTurnId, deckCount, phase, topCardPublic,
        discardCount, discardTopCard, turnsLeftForCurrent,
        pendingAction, pendingMsLeft,
        isDefusing, insertIndex, deckMaxIndex, isPublicInsert, insertPositionText,
        amIDead,
        isGameOver, isWinner, winReasonText,
        lastActionMsg,
        isPreviewing, previewCards,

        playersPublic, playerCount, otherPlayersSorted, shortId,

        chatMessages, chatInput, sendChat, chatBody, timeText,

        cardIcon, cardHelp, isCardPlayable, onCardClick,
        characterCards, cardCount,

        isChoosingTarget, pairCardToPlay, stealTargets, selectTarget, cancelChooseTarget,

        drawCard, confirmInsert, requestRestart, closePreview,
        pendingActionText,

        // æœåŠ¡ç«¯åˆ¤å®šçš„å›åˆ
        isMyTurnServer
      };
    }
  }).mount('#app');
</script>
</body>
</html>
