<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>çˆ†ç‚¸å°é»„äºº - å®Œæ•´ç‰ˆ</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body { background: #222; overflow: hidden; font-family: sans-serif; margin: 0; user-select: none; }

    .scene {
      perspective: 1000px;
      width: 100vw; height: 100vh;
      display: flex; justify-content: center; align-items: center;
    }

    .table {
      width: 90vw; height: 60vh; max-width: 800px;
      background: #2c3e50; border: 8px solid #5d4037; border-radius: 20px;
      transform: rotateX(40deg) translateY(50px);
      transform-style: preserve-3d; position: relative;
      box-shadow: 0 50px 50px rgba(0,0,0,0.5);
    }

    .info-text {
      position: absolute; top: -60px; width: 100%;
      text-align: center; color: white;
      font-size: 18px; text-shadow: 0 2px 4px black;
      transform: translateZ(20px);
    }

    .draw-pile {
      position: absolute; top: 50%; left: 50%;
      width: 100px; height: 140px;
      background: #ff9800;
      border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      font-size: 30px; color: white; font-weight: bold;
      cursor: pointer; box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      transition: 0.3s;
    }

    .my-turn-glow {
      box-shadow: 0 0 30px #00e676; border-color: #00e676;
      transform: translate(-50%, -50%) translateZ(20px) scale(1.1);
    }

    .draw-pile.is-bomb {
      background: #ff5252;
      border-color: #ff8a80;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateZ(20px) scale(1.15); }
      100% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
    }

    .my-hand {
      position: absolute; bottom: 30px; width: 100%;
      display: flex; justify-content: center; gap: 10px;
      transform: translateZ(50px);
      flex-wrap: wrap;
      padding: 0 10px;
    }

    .card {
      width: 70px; height: 100px; background: white; border-radius: 6px;
      display: flex; justify-content: center; align-items: center;
      font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 14px;
      transition: 0.2s;
    }

    .card:hover { transform: translateY(-20px); }

    .card.defuse { background: #b9f6ca; color: #1b5e20; border: 2px solid #00c853; }

    /* è·³è¿‡ç‰Œå¯ç”¨æ—¶é«˜äº® */
    .card.playable {
      border: 2px solid #00e676;
      box-shadow: 0 0 12px rgba(0, 230, 118, 0.7);
      cursor: pointer;
    }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white;
    }

    .slider-container { width: 80%; max-width: 400px; margin: 30px 0; text-align: center; }
    input[type=range] { width: 100%; height: 20px; accent-color: #ff9800; cursor: pointer; }

    .confirm-btn {
      padding: 15px 40px; font-size: 18px; background: #ff5252; color: white;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
      box-shadow: 0 0 20px #ff5252; margin-top: 20px;
    }
    .confirm-btn:active { transform: scale(0.95); }

    .checkbox-wrapper {
      margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px;
      background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 20px;
      border: 1px solid #ff5252;
    }
    input[type=checkbox] { width: 20px; height: 20px; accent-color: #ff5252; cursor: pointer;}
  </style>
</head>

<body>
<div id="app">

  <!-- ç»“ç®—å¼¹çª— -->
  <div v-if="isGameOver" class="modal-overlay" style="background: rgba(44, 62, 80, 0.98);">
    <div style="font-size: 80px; margin-bottom: 20px;">
      {{ isWinner ? 'ğŸ†' : 'ğŸ’€' }}
    </div>

    <h1 style="font-size: 40px; margin: 0;">
      {{ isWinner ? 'ä½ èµ¢äº†ï¼' : 'æ¸¸æˆç»“æŸ' }}
    </h1>

    <p style="font-size: 20px; color: #ccc; margin-top: 10px;">
      {{ winReasonText }}
    </p>

    <button class="confirm-btn"
            style="background: #00e676; box-shadow: 0 0 20px #00e676;"
            @click="requestRestart">
      ğŸ”„ å†æ¥ä¸€å±€
    </button>
  </div>

  <!-- æ­»äº¡å¼¹çª—ï¼šæ³¨æ„ï¼ç»“ç®—æ—¶ä¸æ˜¾ç¤ºï¼Œé¿å…æŒ¡ä½â€œå†æ¥ä¸€å±€â€ -->
  <div v-if="amIDead && !isGameOver" class="modal-overlay" style="background: rgba(50,0,0,0.95);">
    <h1 style="font-size: 50px; color: red;">YOU DIED</h1>
    <p>ä½ ç‚¸äº†ã€‚</p>
    <p style="color:#ccc; margin-top:10px;">ç­‰å¾…æœ¬å±€ç»“æŸ...</p>
  </div>

  <!-- æ‹†å¼¹å¼¹çª— -->
  <div v-if="isDefusing" class="modal-overlay">
    <h1>âš ï¸ ç‚¸å¼¹æ‹†é™¤æˆåŠŸï¼</h1>
    <p>å†³å®šè¦æŠŠç‚¸å¼¹å¡å›å“ªé‡Œ...</p>

    <div class="slider-container">
      <input type="range" v-model="insertIndex" min="0" :max="deckMaxIndex" step="1">

      <div style="display: flex; justify-content: space-between; margin-top: 10px; color: #aaa;">
        <span>ç‰Œåº• (å®‰å…¨)</span>
        <span style="color: #ff9800; font-weight: bold;">{{ insertPositionText }}</span>
        <span>ç‰Œé¡¶ (å±é™©)</span>
      </div>

      <div class="checkbox-wrapper" v-if="parseInt(insertIndex) === deckMaxIndex">
        <input type="checkbox" id="publicBomb" v-model="isPublicInsert">
        <label for="publicBomb" style="cursor: pointer; font-weight: bold;">â˜ ï¸ æ˜ç‰Œæ”¾ç½® (å…¬å¼€å¤„åˆ‘)</label>
      </div>

      <div v-else style="margin-top: 20px; font-size: 12px; color: #666; height: 42px;">
        æš—ç‰ŒåŸ‹è—ä¸­...
      </div>
    </div>

    <button class="confirm-btn" @click="confirmInsert">ç¡®å®šåŸ‹è—</button>
  </div>

  <div class="scene">
    <div class="table">

      <div class="info-text">
        <div v-if="phase === 'waiting'" style="color:#ffca28;">
          ğŸŸ¡ ç­‰å¾…ç©å®¶åŠ å…¥ï¼ˆè‡³å°‘ 2 äººï¼‰
        </div>
        <div v-else-if="phase === 'ended'" style="color:#ffca28;">
          ğŸŸ£ æœ¬å±€å·²ç»“æŸ
        </div>
        <div v-else-if="amIDead">å·²æ­»äº¡</div>
        <div v-else-if="isMyTurn" style="color:#00e676">ğŸŸ¢ è½®åˆ°ä½ äº†</div>
        <div v-else>ğŸ”´ ç­‰å¾…å¯¹æ‰‹...</div>

        <div v-if="lastActionMsg" style="font-size:14px; color: #ffca28; margin-top:5px;">
          {{ lastActionMsg }}
        </div>
      </div>

      <div
        class="draw-pile"
        :class="{
          'my-turn-glow': isMyTurn && !isDefusing && !isGameOver && phase === 'playing',
          'is-bomb': topCardPublic === 'ç‚¸å¼¹'
        }"
        @click="drawCard"
      >
        {{ topCardPublic === 'ç‚¸å¼¹' ? 'â˜ ï¸' : deckCount }}

        <div style="font-size: 12px; position: absolute; bottom: 10px; font-weight: normal;">
          {{ topCardPublic === 'ç‚¸å¼¹' ? 'ä¸‹å¼ å¿…æ­»' : 'ç‚¹å‡»æŠ½ç‰Œ' }}
        </div>
      </div>

      <div class="my-hand">
        <div
          v-for="(card, i) in myHand"
          :key="i"
          class="card"
          :class="{
            'defuse': card === 'æ‹†é™¤',
            'playable': canPlaySkip && card === 'è·³è¿‡'
          }"
          @click="(canPlaySkip && card === 'è·³è¿‡') ? playSkip() : null"
          :title="(canPlaySkip && card === 'è·³è¿‡') ? 'ç‚¹å‡»ä½¿ç”¨ï¼šè·³è¿‡æœ¬å›åˆï¼ˆä¸æŠ½ç‰Œï¼‰' : ''"
        >
          {{ card }}
        </div>
      </div>

    </div>
  </div>

</div>

<script>
  const { createApp, ref, computed } = Vue;
  const socket = io();

  createApp({
    setup() {
      // --- çŠ¶æ€ ---
      const myId = ref('');
      const myHand = ref([]);
      const deckCount = ref(0);
      const currentTurnId = ref(null);
      const amIDead = ref(false);
      const lastActionMsg = ref('');

      const phase = ref('waiting'); // waiting | playing | ended

      const isDefusing = ref(false);
      const insertIndex = ref(0);
      const deckMaxIndex = ref(0);
      const topCardPublic = ref(null);
      const isPublicInsert = ref(false);

      const isGameOver = ref(false);
      const isWinner = ref(false);
      const winReasonText = ref('');

      function applyEnded(wid) {
        isGameOver.value = true;

        if (wid === null || wid === undefined) {
          isWinner.value = false;
          winReasonText.value = "â˜ ï¸ æ— äººå¹¸å­˜ï¼ˆåŒå½’äºå°½ï¼‰";
        } else if (wid === myId.value) {
          isWinner.value = true;
          winReasonText.value = "ğŸ‰ æ­å–œï¼ä½ æ˜¯æœ€åçš„å¹¸å­˜è€…ï¼";
        } else {
          isWinner.value = false;
          winReasonText.value = "ğŸ‘» ä½ è¢«æ·˜æ±°äº†ï¼Œèƒœè€…æ˜¯åˆ«äººã€‚";
        }
      }

      // --- è¿æ¥ ---
      socket.on('connect', () => {
        myId.value = socket.id;
        socket.emit('requestState');
      });

      // --- æ ¸å¿ƒçŠ¶æ€åŒæ­¥ ---
      socket.on('gameState', (data) => {
        if (!myId.value && socket.id) myId.value = socket.id;

        deckCount.value = data.deckCount;
        currentTurnId.value = data.currentTurn;
        topCardPublic.value = data.topCardPublic;

        phase.value = data.phase || 'waiting';

        // åŒæ­¥è‡ªå·±æ•°æ®
        if (myId.value && data.players && data.players[myId.value]) {
          const me = data.players[myId.value];
          myHand.value = me.hand;
          amIDead.value = me.isDead;
        } else {
          if (socket.connected) socket.emit('requestState');
        }

        // ç”¨ phase å†³å®šæ˜¯å¦å¼¹ç»“ç®—
        if (phase.value === 'ended') {
          applyEnded(data.winnerId);
        } else {
          isGameOver.value = false;
          isWinner.value = false;
          winReasonText.value = '';
        }
      });

      socket.on('askInsertBomb', (data) => {
        isDefusing.value = true;
        deckMaxIndex.value = data.maxIndex;
        insertIndex.value = data.maxIndex;
        isPublicInsert.value = false;
      });

      socket.on('playerDied', (data) => {
        if (data.id !== socket.id) lastActionMsg.value = "ğŸ’¥ å¯¹æ‰‹ç‚¸äº†ï¼";
      });

      socket.on('bombInserted', () => {
        lastActionMsg.value = "ğŸ‘€ ç‚¸å¼¹å·²è¢«åŸ‹å›...";
      });

      // è·³è¿‡ç‰Œæç¤º
      socket.on('cardPlayed', (data) => {
        if (!data) return;
        if (data.id === socket.id) lastActionMsg.value = `ğŸƒ ä½ ä½¿ç”¨äº†ã€${data.card}ã€‘`;
        else lastActionMsg.value = `ğŸƒ å¯¹æ‰‹ä½¿ç”¨äº†ã€${data.card}ã€‘`;
      });

      socket.on('gameOver', (data) => {
        applyEnded(data.winnerId);
      });

      socket.on('gameRestarted', () => {
        isGameOver.value = false;
        isWinner.value = false;
        winReasonText.value = '';

        amIDead.value = false;
        isDefusing.value = false;
        lastActionMsg.value = "=== æ–°æ¸¸æˆå¼€å§‹ ===";
        insertIndex.value = 0;
        topCardPublic.value = null;

        socket.emit('requestState');
      });

      socket.on('errorMsg', (data) => {
        if (data && data.message) lastActionMsg.value = "âš ï¸ " + data.message;
      });

      // --- è®¡ç®—å±æ€§ ---
      const isMyTurn = computed(() => {
        return phase.value === 'playing'
          && socket.id === currentTurnId.value
          && !amIDead.value;
      });

      const canPlaySkip = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && isMyTurn.value
          && !isDefusing.value
          && myHand.value.includes('è·³è¿‡');
      });

      const insertPositionText = computed(() => {
        const idx = parseInt(insertIndex.value);
        if (idx === deckMaxIndex.value) return "ç‰Œé¡¶ (æœ€å±é™©)";
        if (idx === 0) return "ç‰Œåº• (æœ€å®‰å…¨)";
        return `ç¬¬ ${idx + 1} å¼ `;
      });

      // --- äº¤äº’ ---
      const drawCard = () => {
        if (phase.value !== 'playing') return;
        if (isMyTurn.value && !isDefusing.value) socket.emit('drawCard');
      };

      const playSkip = () => {
        if (!canPlaySkip.value) return;
        socket.emit('playCard', { card: 'è·³è¿‡' });
      };

      const confirmInsert = () => {
        isDefusing.value = false;
        socket.emit('insertBomb', {
          index: parseInt(insertIndex.value),
          isPublic: isPublicInsert.value
        });
      };

      const requestRestart = () => {
        socket.emit('restartGame');
      };

      return {
        // state
        myHand, deckCount, currentTurnId, amIDead, lastActionMsg,
        phase,
        isDefusing, insertIndex, deckMaxIndex, insertPositionText, topCardPublic, isPublicInsert,
        isGameOver, isWinner, winReasonText,

        // computed
        isMyTurn, canPlaySkip,

        // actions
        drawCard, playSkip, confirmInsert, requestRestart
      };
    }
  }).mount('#app');
</script>
</body>
</html>
