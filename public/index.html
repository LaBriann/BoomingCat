<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>çˆ†ç‚¸å°é»„äºº - å®Œæ•´ç‰ˆ</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body { background: #222; overflow: hidden; font-family: sans-serif; margin: 0; user-select: none; }

    .scene {
      perspective: 1000px;
      width: 100vw; height: 100vh;
      display: flex; justify-content: center; align-items: center;
    }

    .table {
      width: 90vw; height: 60vh; max-width: 800px;
      background: #2c3e50; border: 8px solid #5d4037; border-radius: 20px;
      transform: rotateX(40deg) translateY(50px);
      transform-style: preserve-3d; position: relative;
      box-shadow: 0 50px 50px rgba(0,0,0,0.5);
    }

    .info-text {
      position: absolute; top: -60px; width: 100%;
      text-align: center; color: white;
      font-size: 18px; text-shadow: 0 2px 4px black;
      transform: translateZ(20px);
    }

    .draw-pile {
      position: absolute; top: 50%; left: 50%;
      width: 100px; height: 140px;
      background: #ff9800;
      border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      font-size: 30px; color: white; font-weight: bold;
      cursor: pointer; box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      transition: 0.3s;
    }

    .my-turn-glow {
      box-shadow: 0 0 30px #00e676; border-color: #00e676;
      transform: translate(-50%, -50%) translateZ(20px) scale(1.1);
    }

    .draw-pile.is-bomb {
      background: #ff5252;
      border-color: #ff8a80;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateZ(20px) scale(1.15); }
      100% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
    }

    /* å¼ƒç‰Œå † */
    .discard-pile {
      position: absolute;
      top: 50%;
      left: 25%;
      width: 90px;
      height: 125px;
      background: #607d8b;
      border: 4px solid white;
      border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      user-select: none;
    }

    .discard-pile .count {
      position: absolute;
      bottom: 10px;
      font-size: 12px;
      font-weight: normal;
      opacity: 0.95;
    }

    .discard-pile .topIcon {
      font-size: 34px;
      line-height: 1;
    }

    .discard-pile .topText {
      position: absolute;
      top: 8px;
      font-size: 12px;
      font-weight: normal;
      opacity: 0.95;
    }

    .my-hand {
      position: absolute; bottom: 30px; width: 100%;
      display: flex; justify-content: center; gap: 10px;
      transform: translateZ(50px);
      flex-wrap: wrap;
      padding: 0 10px;
    }

    .card {
      width: 70px; height: 100px; background: white; border-radius: 6px;
      display: flex; justify-content: center; align-items: center;
      font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 14px;
      transition: 0.2s;
    }

    .card:hover { transform: translateY(-20px); }

    .card.defuse { background: #b9f6ca; color: #1b5e20; border: 2px solid #00c853; }

    .card.playable {
      border: 2px solid #00e676;
      box-shadow: 0 0 12px rgba(0, 230, 118, 0.7);
      cursor: pointer;
    }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white;
    }

    .slider-container { width: 80%; max-width: 400px; margin: 30px 0; text-align: center; }
    input[type=range] { width: 100%; height: 20px; accent-color: #ff9800; cursor: pointer; }

    .confirm-btn {
      padding: 15px 40px; font-size: 18px; background: #ff5252; color: white;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
      box-shadow: 0 0 20px #ff5252; margin-top: 20px;
    }
    .confirm-btn:active { transform: scale(0.95); }

    .checkbox-wrapper {
      margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px;
      background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 20px;
      border: 1px solid #ff5252;
    }
    input[type=checkbox] { width: 20px; height: 20px; accent-color: #ff5252; cursor: pointer;}

    /* é¢„çŸ¥å¡ç‰Œå±•ç¤º */
    .preview-row {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .preview-card {
      width: 90px;
      height: 130px;
      border-radius: 10px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.25);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .preview-card .icon { font-size: 40px; margin-bottom: 10px; }
    .preview-card .name { font-size: 14px; opacity: 0.95; }
  </style>
</head>

<body>
<div id="app">

  <!-- ç»“ç®—å¼¹çª— -->
  <div v-if="isGameOver" class="modal-overlay" style="background: rgba(44, 62, 80, 0.98);">
    <div style="font-size: 80px; margin-bottom: 20px;">
      {{ isWinner ? 'ğŸ†' : 'ğŸ’€' }}
    </div>

    <h1 style="font-size: 40px; margin: 0;">
      {{ isWinner ? 'ä½ èµ¢äº†ï¼' : 'æ¸¸æˆç»“æŸ' }}
    </h1>

    <p style="font-size: 20px; color: #ccc; margin-top: 10px;">
      {{ winReasonText }}
    </p>

    <button class="confirm-btn"
            style="background: #00e676; box-shadow: 0 0 20px #00e676;"
            @click="requestRestart">
      ğŸ”„ å†æ¥ä¸€å±€
    </button>
  </div>

  <!-- æ­»äº¡å¼¹çª—ï¼ˆç»“ç®—æ—¶ä¸æ˜¾ç¤ºï¼‰ -->
  <div v-if="amIDead && !isGameOver" class="modal-overlay" style="background: rgba(50,0,0,0.95);">
    <h1 style="font-size: 50px; color: red;">YOU DIED</h1>
    <p>ä½ ç‚¸äº†ã€‚</p>
    <p style="color:#ccc; margin-top:10px;">ç­‰å¾…æœ¬å±€ç»“æŸ...</p>
  </div>

  <!-- é¢„çŸ¥å¼¹çª— -->
  <div v-if="isPreviewing" class="modal-overlay" style="background: rgba(0, 0, 0, 0.92);">
    <h1 style="margin:0;">ğŸ‘ï¸ é¢„çŸ¥ï¼šç‰Œé¡¶ä¸‰å¼ </h1>
    <p style="color:#ccc; margin-top:10px;">ä»…ä½ å¯è§ã€‚é¡ºåºä¸ºï¼šä»ç‰Œé¡¶åˆ°æ›´ä¸‹é¢ã€‚</p>

    <div class="preview-row">
      <div class="preview-card" v-for="(c, idx) in previewCards" :key="idx">
        <div class="icon">{{ cardIcon(c) }}</div>
        <div class="name">{{ c }}</div>
      </div>
      <div v-if="previewCards.length === 0" style="color:#ccc; margin-top:10px;">
        ç‰Œåº“ä¸è¶³ä¸‰å¼ 
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#00e676; box-shadow:0 0 20px #00e676;"
            @click="closePreview"
    >
      çŸ¥é“äº†
    </button>
  </div>

  <!-- æ‹†å¼¹å¼¹çª— -->
  <div v-if="isDefusing" class="modal-overlay">
    <h1>âš ï¸ ç‚¸å¼¹æ‹†é™¤æˆåŠŸï¼</h1>
    <p>å†³å®šè¦æŠŠç‚¸å¼¹å¡å›å“ªé‡Œ...</p>

    <div class="slider-container">
      <input type="range" v-model="insertIndex" min="0" :max="deckMaxIndex" step="1">

      <div style="display: flex; justify-content: space-between; margin-top: 10px; color: #aaa;">
        <span>ç‰Œåº• (å®‰å…¨)</span>
        <span style="color: #ff9800; font-weight: bold;">{{ insertPositionText }}</span>
        <span>ç‰Œé¡¶ (å±é™©)</span>
      </div>

      <div class="checkbox-wrapper" v-if="parseInt(insertIndex) === deckMaxIndex">
        <input type="checkbox" id="publicBomb" v-model="isPublicInsert">
        <label for="publicBomb" style="cursor: pointer; font-weight: bold;">â˜ ï¸ æ˜ç‰Œæ”¾ç½® (å…¬å¼€å¤„åˆ‘)</label>
      </div>

      <div v-else style="margin-top: 20px; font-size: 12px; color: #666; height: 42px;">
        æš—ç‰ŒåŸ‹è—ä¸­...
      </div>
    </div>

    <button class="confirm-btn" @click="confirmInsert">ç¡®å®šåŸ‹è—</button>
  </div>

  <div class="scene">
    <div class="table">

      <div class="info-text">
        <div v-if="phase === 'waiting'" style="color:#ffca28;">
          ğŸŸ¡ ç­‰å¾…ç©å®¶åŠ å…¥ï¼ˆè‡³å°‘ 2 äººï¼‰
        </div>
        <div v-else-if="phase === 'ended'" style="color:#ffca28;">
          ğŸŸ£ æœ¬å±€å·²ç»“æŸ
        </div>
        <div v-else-if="amIDead">å·²æ­»äº¡</div>
        <div v-else-if="isMyTurn" style="color:#00e676">
          ğŸŸ¢ è½®åˆ°ä½ äº†ï¼ˆå‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>
        <div v-else>
          ğŸ”´ ç­‰å¾…å¯¹æ‰‹...ï¼ˆå¯¹æ‰‹å‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>

        <div v-if="lastActionMsg" style="font-size:14px; color: #ffca28; margin-top:5px;">
          {{ lastActionMsg }}
        </div>
      </div>

      <!-- å¼ƒç‰Œå †ï¼ˆå›¾æ ‡ç‰ˆï¼‰ -->
      <div class="discard-pile" :title="discardTopCard ? ('é¡¶ç‰Œï¼š' + discardTopCard) : 'å¼ƒç‰Œå †ä¸ºç©º'">
        <div class="topText">å¼ƒç‰Œå †</div>
        <div class="topIcon">{{ cardIcon(discardTopCard) }}</div>
        <div class="count">æ•°é‡ï¼š{{ discardCount }}</div>
      </div>

      <!-- ç‰Œåº“ -->
      <div
        class="draw-pile"
        :class="{
          'my-turn-glow': isMyTurn && !isDefusing && !isGameOver && phase === 'playing',
          'is-bomb': topCardPublic === 'ç‚¸å¼¹'
        }"
        @click="drawCard"
      >
        {{ topCardPublic === 'ç‚¸å¼¹' ? 'â˜ ï¸' : deckCount }}

        <div style="font-size: 12px; position: absolute; bottom: 10px; font-weight: normal;">
          {{ topCardPublic === 'ç‚¸å¼¹' ? 'ä¸‹å¼ å¿…æ­»' : 'ç‚¹å‡»æŠ½ç‰Œ' }}
        </div>
      </div>

      <!-- æ‰‹ç‰Œ -->
      <div class="my-hand">
        <div
          v-for="(card, i) in myHand"
          :key="i"
          class="card"
          :class="{
            'defuse': card === 'æ‹†é™¤',
            'playable': canPlayActiveCard && isActiveCard(card)
          }"
          @click="isActiveCard(card) ? playActiveCard(card) : null"
          :title="cardHelp(card)"
        >
          {{ card }}
        </div>
      </div>

    </div>
  </div>

</div>

<script>
  const { createApp, ref, computed } = Vue;
  const socket = io();

  createApp({
    setup() {
      const myId = ref('');
      const myHand = ref([]);
      const deckCount = ref(0);
      const currentTurnId = ref(null);
      const amIDead = ref(false);
      const lastActionMsg = ref('');

      const phase = ref('waiting');

      const isDefusing = ref(false);
      const insertIndex = ref(0);
      const deckMaxIndex = ref(0);
      const topCardPublic = ref(null);
      const isPublicInsert = ref(false);

      const isGameOver = ref(false);
      const isWinner = ref(false);
      const winReasonText = ref('');

      // å¼ƒç‰Œå †
      const discardCount = ref(0);
      const discardTopCard = ref(null);

      // æ”»å‡»å¯è§†åŒ–ï¼šå½“å‰ç©å®¶è¿˜å‰©å›åˆæ•°
      const turnsLeftForCurrent = ref(0);

      // é¢„çŸ¥å¼¹çª—
      const isPreviewing = ref(false);
      const previewCards = ref([]);

      const activeCards = ['è·³è¿‡', 'æ”»å‡»', 'é¢„çŸ¥', 'å…‹éš†ç‰Œ'];

      const isActiveCard = (card) => activeCards.includes(card);

      const cardIcon = (card) => {
        switch (card) {
          case 'ç‚¸å¼¹': return 'â˜ ï¸';
          case 'æ‹†é™¤': return 'ğŸ›¡';
          case 'è·³è¿‡': return 'â­';
          case 'æ”»å‡»': return 'âš”ï¸';
          case 'é¢„çŸ¥': return 'ğŸ‘ï¸';
          case 'å…‹éš†ç‰Œ': return 'ğŸ§¬';
          case 'æ™®é€šç‰Œ': return 'ğŸŸ¦';
          case null:
          case undefined:
          default: return 'â€”';
        }
      };

      const cardHelp = (card) => {
        if (card === 'è·³è¿‡') return 'è·³è¿‡ï¼šç»“æŸæœ¬å›åˆï¼ˆä¸æŠ½ç‰Œï¼‰';
        if (card === 'æ”»å‡»') return 'æ”»å‡»ï¼šä½ ä¸æŠ½ç‰Œï¼Œå¼ºåˆ¶ä¸‹å®¶è¿èµ°ä¸¤å›åˆï¼ˆå¯å åŠ ï¼‰';
        if (card === 'é¢„çŸ¥') return 'é¢„çŸ¥ï¼šæŸ¥çœ‹ç‰Œé¡¶ä¸‰å¼ ï¼ˆä¸ç»“æŸå›åˆï¼‰';
        if (card === 'å…‹éš†ç‰Œ') return 'å…‹éš†ç‰Œï¼šå…‹éš†å¼ƒç‰Œå †é¡¶ç‰Œæ•ˆæœï¼ˆæ”¯æŒï¼šè·³è¿‡/æ”»å‡»/é¢„çŸ¥ï¼‰';
        return '';
      };

      function applyEnded(wid) {
        isGameOver.value = true;
        if (wid === null || wid === undefined) {
          isWinner.value = false;
          winReasonText.value = "â˜ ï¸ æ— äººå¹¸å­˜ï¼ˆåŒå½’äºå°½ï¼‰";
        } else if (wid === myId.value) {
          isWinner.value = true;
          winReasonText.value = "ğŸ‰ æ­å–œï¼ä½ æ˜¯æœ€åçš„å¹¸å­˜è€…ï¼";
        } else {
          isWinner.value = false;
          winReasonText.value = "ğŸ‘» ä½ è¢«æ·˜æ±°äº†ï¼Œèƒœè€…æ˜¯åˆ«äººã€‚";
        }
      }

      socket.on('connect', () => {
        myId.value = socket.id;
        socket.emit('requestState');
      });

      socket.on('gameState', (data) => {
        if (!myId.value && socket.id) myId.value = socket.id;

        deckCount.value = data.deckCount;
        currentTurnId.value = data.currentTurn;
        topCardPublic.value = data.topCardPublic;

        phase.value = data.phase || 'waiting';

        discardCount.value = data.discardCount ?? 0;
        discardTopCard.value = data.discardTopCard ?? null;

        turnsLeftForCurrent.value = data.turnsLeftForCurrent ?? 0;

        if (myId.value && data.players && data.players[myId.value]) {
          const me = data.players[myId.value];
          myHand.value = me.hand;
          amIDead.value = me.isDead;
        } else {
          if (socket.connected) socket.emit('requestState');
        }

        if (phase.value === 'ended') {
          applyEnded(data.winnerId);
        } else {
          isGameOver.value = false;
          isWinner.value = false;
          winReasonText.value = '';
        }
      });

      socket.on('askInsertBomb', (data) => {
        isDefusing.value = true;
        deckMaxIndex.value = data.maxIndex;
        insertIndex.value = data.maxIndex;
        isPublicInsert.value = false;
      });

      socket.on('previewCards', (data) => {
        previewCards.value = (data && data.cards) ? data.cards : [];
        isPreviewing.value = true;
      });

      socket.on('playerDied', (data) => {
        if (data.id !== socket.id) lastActionMsg.value = "ğŸ’¥ å¯¹æ‰‹ç‚¸äº†ï¼";
      });

      socket.on('bombInserted', () => {
        lastActionMsg.value = "ğŸ‘€ ç‚¸å¼¹å·²è¢«åŸ‹å›...";
      });

      socket.on('cardPlayed', (data) => {
        if (!data) return;
        const actor = (data.id === socket.id) ? 'ä½ ' : 'å¯¹æ‰‹';

        if (data.card === 'å…‹éš†ç‰Œ' && data.clonedCard) {
          lastActionMsg.value = `ğŸ§¬ ${actor} ä½¿ç”¨äº†ã€å…‹éš†ç‰Œã€‘ï¼Œå…‹éš†ã€${data.clonedCard}ã€‘æ•ˆæœ`;
        } else {
          lastActionMsg.value = `ğŸƒ ${actor} ä½¿ç”¨äº†ã€${data.card}ã€‘`;
        }
      });

      socket.on('gameOver', (data) => {
        applyEnded(data.winnerId);
      });

      socket.on('gameRestarted', () => {
        isGameOver.value = false;
        isWinner.value = false;
        winReasonText.value = '';

        amIDead.value = false;
        isDefusing.value = false;
        lastActionMsg.value = "=== æ–°æ¸¸æˆå¼€å§‹ ===";
        insertIndex.value = 0;
        topCardPublic.value = null;

        isPreviewing.value = false;
        previewCards.value = [];

        socket.emit('requestState');
      });

      socket.on('errorMsg', (data) => {
        if (data && data.message) lastActionMsg.value = "âš ï¸ " + data.message;
      });

      const isMyTurn = computed(() => {
        return phase.value === 'playing'
          && socket.id === currentTurnId.value
          && !amIDead.value;
      });

      const canPlayActiveCard = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && isMyTurn.value
          && !isDefusing.value;
      });

      const insertPositionText = computed(() => {
        const idx = parseInt(insertIndex.value);
        if (idx === deckMaxIndex.value) return "ç‰Œé¡¶ (æœ€å±é™©)";
        if (idx === 0) return "ç‰Œåº• (æœ€å®‰å…¨)";
        return `ç¬¬ ${idx + 1} å¼ `;
      });

      const drawCard = () => {
        if (phase.value !== 'playing') return;
        if (isMyTurn.value && !isDefusing.value) socket.emit('drawCard');
      };

      const playActiveCard = (card) => {
        if (!myHand.value.includes(card)) {
          lastActionMsg.value = `âš ï¸ ä½ æ²¡æœ‰ã€${card}ã€‘`;
          return;
        }
        if (!canPlayActiveCard.value) {
          lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½å‡ºç‰Œï¼ˆéä½ å›åˆ/æ‹†å¼¹ä¸­/æœªå¼€å±€/å·²ç»“æŸï¼‰";
          return;
        }
        socket.emit('playCard', { card });
      };

      const closePreview = () => {
        isPreviewing.value = false;
        previewCards.value = [];
      };

      const confirmInsert = () => {
        isDefusing.value = false;
        socket.emit('insertBomb', {
          index: parseInt(insertIndex.value),
          isPublic: isPublicInsert.value
        });
      };

      const requestRestart = () => {
        socket.emit('restartGame');
      };

      return {
        myHand, deckCount, currentTurnId, amIDead, lastActionMsg,
        phase,
        isDefusing, insertIndex, deckMaxIndex, insertPositionText, topCardPublic, isPublicInsert,
        isGameOver, isWinner, winReasonText,

        discardCount, discardTopCard, cardIcon,

        turnsLeftForCurrent,

        isPreviewing, previewCards, closePreview,

        isMyTurn, canPlayActiveCard, isActiveCard, cardHelp,

        drawCard, playActiveCard, confirmInsert, requestRestart
      };
    }
  }).mount('#app');
</script>
</body>
</html>
