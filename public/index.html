<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>çˆ†ç‚¸å°é»„äºº - å®Œæ•´ç‰ˆ</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body { background: #222; overflow: hidden; font-family: sans-serif; margin: 0; user-select: none; }
    .scene { perspective: 1000px; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    .table {
      width: 90vw; height: 60vh; max-width: 800px;
      background: #2c3e50; border: 8px solid #5d4037; border-radius: 20px;
      transform: rotateX(40deg) translateY(50px);
      transform-style: preserve-3d; position: relative;
      box-shadow: 0 50px 50px rgba(0,0,0,0.5);
    }
    .info-text {
      position: absolute; top: -72px; width: 100%;
      text-align: center; color: white;
      font-size: 18px; text-shadow: 0 2px 4px black;
      transform: translateZ(20px);
    }
    .pending-banner { margin-top: 6px; font-size: 13px; color: #ffca28; }

    .draw-pile {
      position: absolute; top: 50%; left: 50%;
      width: 100px; height: 140px;
      background: #ff9800;
      border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      font-size: 30px; color: white; font-weight: bold;
      cursor: pointer; box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      transition: 0.3s;
    }
    .my-turn-glow {
      box-shadow: 0 0 30px #00e676; border-color: #00e676;
      transform: translate(-50%, -50%) translateZ(20px) scale(1.1);
    }
    .draw-pile.is-bomb {
      background: #ff5252;
      border-color: #ff8a80;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateZ(20px) scale(1.15); }
      100% { transform: translate(-50%, -50%) translateZ(20px) scale(1.1); }
    }

    .discard-pile {
      position: absolute; top: 50%; left: 25%;
      width: 90px; height: 125px;
      background: #607d8b; border: 4px solid white; border-radius: 8px;
      transform: translate(-50%, -50%) translateZ(2px);
      display: flex; justify-content: center; align-items: center;
      color: white; font-weight: bold;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      user-select: none;
    }
    .discard-pile .count { position: absolute; bottom: 10px; font-size: 12px; font-weight: normal; opacity: 0.95; }
    .discard-pile .topIcon { font-size: 34px; line-height: 1; }
    .discard-pile .topText { position: absolute; top: 8px; font-size: 12px; font-weight: normal; opacity: 0.95; }

    .my-hand {
      position: absolute; bottom: 30px; width: 100%;
      display: flex; justify-content: center; gap: 10px;
      transform: translateZ(50px);
      flex-wrap: wrap; padding: 0 10px;
    }
    .card {
      width: 70px; height: 100px; background: white; border-radius: 6px;
      display: flex; justify-content: center; align-items: center;
      font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 14px;
      transition: 0.2s;
    }
    .card:hover { transform: translateY(-20px); }
    .card.defuse { background: #b9f6ca; color: #1b5e20; border: 2px solid #00c853; }
    .card.playable {
      border: 2px solid #00e676;
      box-shadow: 0 0 12px rgba(0, 230, 118, 0.7);
      cursor: pointer;
    }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white;
    }
    .slider-container { width: 80%; max-width: 400px; margin: 30px 0; text-align: center; }
    input[type=range] { width: 100%; height: 20px; accent-color: #ff9800; cursor: pointer; }
    .confirm-btn {
      padding: 15px 40px; font-size: 18px; background: #ff5252; color: white;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
      box-shadow: 0 0 20px #ff5252; margin-top: 20px;
    }
    .confirm-btn:active { transform: scale(0.95); }
    .checkbox-wrapper {
      margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px;
      background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 20px;
      border: 1px solid #ff5252;
    }
    input[type=checkbox] { width: 20px; height: 20px; accent-color: #ff5252; cursor: pointer;}

    .preview-row { display:flex; gap:12px; margin-top:20px; flex-wrap:wrap; justify-content:center; }
    .preview-card {
      width: 90px; height: 130px; border-radius: 10px;
      background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .preview-card .icon { font-size: 40px; margin-bottom: 10px; }
    .preview-card .name { font-size: 14px; opacity: 0.95; }
  </style>
</head>

<body>
<div id="app">

  <!-- ç»“ç®—å¼¹çª— -->
  <div v-if="isGameOver" class="modal-overlay" style="background: rgba(44, 62, 80, 0.98);">
    <div style="font-size: 80px; margin-bottom: 20px;">
      {{ isWinner ? 'ğŸ†' : 'ğŸ’€' }}
    </div>

    <h1 style="font-size: 40px; margin: 0;">
      {{ isWinner ? 'ä½ èµ¢äº†ï¼' : 'æ¸¸æˆç»“æŸ' }}
    </h1>

    <p style="font-size: 20px; color: #ccc; margin-top: 10px;">
      {{ winReasonText }}
    </p>

    <button class="confirm-btn"
            style="background: #00e676; box-shadow: 0 0 20px #00e676;"
            @click="requestRestart">
      ğŸ”„ å†æ¥ä¸€å±€
    </button>
  </div>

  <!-- æ­»äº¡å¼¹çª—ï¼ˆç»“ç®—æ—¶ä¸æ˜¾ç¤ºï¼‰ -->
  <div v-if="amIDead && !isGameOver" class="modal-overlay" style="background: rgba(50,0,0,0.95);">
    <h1 style="font-size: 50px; color: red;">YOU DIED</h1>
    <p>ä½ ç‚¸äº†ã€‚</p>
    <p style="color:#ccc; margin-top:10px;">ç­‰å¾…æœ¬å±€ç»“æŸ...</p>
  </div>

  <!-- é¢„çŸ¥å¼¹çª— -->
  <div v-if="isPreviewing" class="modal-overlay" style="background: rgba(0, 0, 0, 0.92);">
    <h1 style="margin:0;">ğŸ‘ï¸ é¢„çŸ¥ï¼šç‰Œé¡¶ä¸‰å¼ </h1>
    <p style="color:#ccc; margin-top:10px;">ä»…ä½ å¯è§ã€‚é¡ºåºä¸ºï¼šä»ç‰Œé¡¶åˆ°æ›´ä¸‹é¢ã€‚</p>

    <div class="preview-row">
      <div class="preview-card" v-for="(c, idx) in previewCards" :key="idx">
        <div class="icon">{{ cardIcon(c) }}</div>
        <div class="name">{{ c }}</div>
      </div>
      <div v-if="previewCards.length === 0" style="color:#ccc; margin-top:10px;">
        ç‰Œåº“ä¸è¶³ä¸‰å¼ 
      </div>
    </div>

    <button class="confirm-btn"
            style="background:#00e676; box-shadow:0 0 20px #00e676;"
            @click="closePreview">
      çŸ¥é“äº†
    </button>
  </div>

  <!-- æ‹†å¼¹å¼¹çª— -->
  <div v-if="isDefusing" class="modal-overlay">
    <h1>âš ï¸ ç‚¸å¼¹æ‹†é™¤æˆåŠŸï¼</h1>
    <p>å†³å®šè¦æŠŠç‚¸å¼¹å¡å›å“ªé‡Œ...</p>

    <div class="slider-container">
      <input type="range" v-model="insertIndex" min="0" :max="deckMaxIndex" step="1">

      <div style="display: flex; justify-content: space-between; margin-top: 10px; color: #aaa;">
        <span>ç‰Œåº• (å®‰å…¨)</span>
        <span style="color: #ff9800; font-weight: bold;">{{ insertPositionText }}</span>
        <span>ç‰Œé¡¶ (å±é™©)</span>
      </div>

      <div class="checkbox-wrapper" v-if="parseInt(insertIndex) === deckMaxIndex">
        <input type="checkbox" id="publicBomb" v-model="isPublicInsert">
        <label for="publicBomb" style="cursor: pointer; font-weight: bold;">â˜ ï¸ æ˜ç‰Œæ”¾ç½® (å…¬å¼€å¤„åˆ‘)</label>
      </div>

      <div v-else style="margin-top: 20px; font-size: 12px; color: #666; height: 42px;">
        æš—ç‰ŒåŸ‹è—ä¸­...
      </div>
    </div>

    <button class="confirm-btn" @click="confirmInsert">ç¡®å®šåŸ‹è—</button>
  </div>

  <div class="scene">
    <div class="table">

      <div class="info-text">
        <div v-if="phase === 'waiting'" style="color:#ffca28;">
          ğŸŸ¡ ç­‰å¾…ç©å®¶åŠ å…¥ï¼ˆè‡³å°‘ 2 äººï¼‰
        </div>
        <div v-else-if="phase === 'ended'" style="color:#ffca28;">
          ğŸŸ£ æœ¬å±€å·²ç»“æŸ
        </div>
        <div v-else-if="amIDead">å·²æ­»äº¡</div>
        <div v-else-if="isMyTurn" style="color:#00e676">
          ğŸŸ¢ è½®åˆ°ä½ äº†ï¼ˆå‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>
        <div v-else>
          ğŸ”´ ç­‰å¾…å¯¹æ‰‹...ï¼ˆå½“å‰ç©å®¶å‰©ä½™å›åˆï¼š{{ turnsLeftForCurrent }}ï¼‰
        </div>

        <div class="pending-banner" v-if="pendingAction">
          â³ å¾…ç»“ç®—ï¼š{{ pendingActionText }} ï½œé˜»æ­¢æ¬¡æ•°ï¼š{{ pendingAction.nopeCount }} ï½œå‰©ä½™ï¼š{{ pendingMsLeft }}ms
        </div>

        <div v-if="lastActionMsg" style="font-size:14px; color: #ffca28; margin-top:5px;">
          {{ lastActionMsg }}
        </div>
      </div>

      <!-- å¼ƒç‰Œå † -->
      <div class="discard-pile" :title="discardTopCard ? ('é¡¶ç‰Œï¼š' + discardTopCard) : 'å¼ƒç‰Œå †ä¸ºç©º'">
        <div class="topText">å¼ƒç‰Œå †</div>
        <div class="topIcon">{{ cardIcon(discardTopCard) }}</div>
        <div class="count">æ•°é‡ï¼š{{ discardCount }}</div>
      </div>

      <!-- ç‰Œåº“ -->
      <div
        class="draw-pile"
        :class="{
          'my-turn-glow': isMyTurn && !isDefusing && !isGameOver && phase === 'playing',
          'is-bomb': topCardPublic === 'ç‚¸å¼¹'
        }"
        @click="drawCard"
      >
        {{ topCardPublic === 'ç‚¸å¼¹' ? 'â˜ ï¸' : deckCount }}
        <div style="font-size: 12px; position: absolute; bottom: 10px; font-weight: normal;">
          {{ topCardPublic === 'ç‚¸å¼¹' ? 'ä¸‹å¼ å¿…æ­»' : 'ç‚¹å‡»æŠ½ç‰Œ' }}
        </div>
      </div>

      <!-- æ‰‹ç‰Œ -->
      <div class="my-hand">
        <div
          v-for="(card, i) in myHand"
          :key="i"
          class="card"
          :class="{
            'defuse': card === 'æ‹†é™¤',
            'playable': isCardPlayable(card)
          }"
          @click="onCardClick(card)"
          :title="cardHelp(card)"
        >
          {{ card }}
        </div>
      </div>

    </div>
  </div>

</div>

<script>
  const { createApp, ref, computed, onMounted, onUnmounted } = Vue;
  const socket = io();

  createApp({
    setup() {
      const myId = ref('');
      const myHand = ref([]);
      const deckCount = ref(0);
      const currentTurnId = ref(null);
      const amIDead = ref(false);
      const lastActionMsg = ref('');

      const phase = ref('waiting');

      const isDefusing = ref(false);
      const insertIndex = ref(0);
      const deckMaxIndex = ref(0);
      const topCardPublic = ref(null);
      const isPublicInsert = ref(false);

      const isGameOver = ref(false);
      const isWinner = ref(false);
      const winReasonText = ref('');

      const discardCount = ref(0);
      const discardTopCard = ref(null);

      const turnsLeftForCurrent = ref(0);

      const isPreviewing = ref(false);
      const previewCards = ref([]);

      const pendingAction = ref(null);
      const pendingMsLeft = ref(0);
      let msTimer = null;

      const activeTurnCards = ['è·³è¿‡', 'æ”»å‡»', 'é¢„çŸ¥', 'å…‹éš†ç‰Œ', 'åº•æŠ½', 'æ´—æ··'];
      const nopeCard = 'é˜»æ­¢';

      const cardIcon = (card) => {
        switch (card) {
          case 'ç‚¸å¼¹': return 'â˜ ï¸';
          case 'æ‹†é™¤': return 'ğŸ›¡';
          case 'è·³è¿‡': return 'â­';
          case 'æ”»å‡»': return 'âš”ï¸';
          case 'é¢„çŸ¥': return 'ğŸ‘ï¸';
          case 'å…‹éš†ç‰Œ': return 'ğŸ§¬';
          case 'é˜»æ­¢': return 'âœ‹';
          case 'åº•æŠ½': return 'â¬‡ï¸';
          case 'æ´—æ··': return 'ğŸ”€';
          case 'æ™®é€šç‰Œ': return 'ğŸŸ¦';
          default: return 'â€”';
        }
      };

      const cardHelp = (card) => {
        if (card === 'è·³è¿‡') return 'è·³è¿‡ï¼šç»“æŸæœ¬å›åˆï¼ˆä¸æŠ½ç‰Œï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ”»å‡»') return 'æ”»å‡»ï¼šç»“æŸå½“å‰å›åˆå¹¶è®©ä¸‹å®¶æ€»å…± 2 å›åˆï¼ˆå¯å åŠ ï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é¢„çŸ¥') return 'é¢„çŸ¥ï¼šæŸ¥çœ‹ç‰Œé¡¶ä¸‰å¼ ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'å…‹éš†ç‰Œ') return 'å…‹éš†ç‰Œï¼šå…‹éš†å¼ƒç‰Œå †é¡¶ç‰Œæ•ˆæœï¼ˆæ”¯æŒï¼šè·³è¿‡/æ”»å‡»/é¢„çŸ¥/åº•æŠ½/æ´—æ··ï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'é˜»æ­¢') return 'é˜»æ­¢ï¼šå¯åœ¨éè‡ªå·±å›åˆä½¿ç”¨ï¼Œä½¿å¾…ç»“ç®—åŠ¨ä½œå¤±æ•ˆï¼ˆé˜»æ­¢å¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'åº•æŠ½') return 'åº•æŠ½ï¼šä»ç‰Œåº•æŠ½ 1 å¼ ï¼Œä½œä¸ºæœ¬å›åˆæŠ½ç‰Œå¹¶ç»“æŸå›åˆï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        if (card === 'æ´—æ··') return 'æ´—æ··ï¼šé‡æ–°æ´—æ··å½“å‰å‰©ä½™ç‰Œå †ï¼Œå¹¶å…³é—­æ˜ç‰Œï¼ˆä¸ç»“æŸå›åˆï¼‰ï¼ˆå¯è¢«é˜»æ­¢ï¼‰';
        return '';
      };

      function applyEnded(wid) {
        isGameOver.value = true;
        if (wid === null || wid === undefined) {
          isWinner.value = false;
          winReasonText.value = "â˜ ï¸ æ— äººå¹¸å­˜ï¼ˆåŒå½’äºå°½ï¼‰";
        } else if (wid === myId.value) {
          isWinner.value = true;
          winReasonText.value = "ğŸ‰ æ­å–œï¼ä½ æ˜¯æœ€åçš„å¹¸å­˜è€…ï¼";
        } else {
          isWinner.value = false;
          winReasonText.value = "ğŸ‘» ä½ è¢«æ·˜æ±°äº†ï¼Œèƒœè€…æ˜¯åˆ«äººã€‚";
        }
      }

      socket.on('connect', () => {
        myId.value = socket.id;
        socket.emit('requestState');
      });

      socket.on('gameState', (data) => {
        if (!myId.value && socket.id) myId.value = socket.id;

        deckCount.value = data.deckCount;
        currentTurnId.value = data.currentTurn;
        topCardPublic.value = data.topCardPublic;

        phase.value = data.phase || 'waiting';

        discardCount.value = data.discardCount ?? 0;
        discardTopCard.value = data.discardTopCard ?? null;

        turnsLeftForCurrent.value = data.turnsLeftForCurrent ?? 0;

        pendingAction.value = data.pendingAction ?? null;

        if (myId.value && data.players && data.players[myId.value]) {
          const me = data.players[myId.value];
          myHand.value = me.hand;
          amIDead.value = me.isDead;
        }

        if (phase.value === 'ended') {
          applyEnded(data.winnerId);
        } else {
          isGameOver.value = false;
          isWinner.value = false;
          winReasonText.value = '';
        }
      });

      socket.on('askInsertBomb', (data) => {
        isDefusing.value = true;
        deckMaxIndex.value = data.maxIndex;
        insertIndex.value = data.maxIndex;
        isPublicInsert.value = false;
      });

      socket.on('previewCards', (data) => {
        previewCards.value = (data && data.cards) ? data.cards : [];
        isPreviewing.value = true;
      });

      socket.on('cardPlayed', (data) => {
        if (!data) return;
        const actor = (data.id === socket.id) ? 'ä½ ' : 'å¯¹æ‰‹';
        if (data.card === 'å…‹éš†ç‰Œ' && data.clonedCard) {
          lastActionMsg.value = `ğŸ§¬ ${actor} ä½¿ç”¨ã€å…‹éš†ç‰Œã€‘ï¼Œç›®æ ‡ã€${data.clonedCard}ã€‘`;
        } else {
          lastActionMsg.value = `ğŸƒ ${actor} ä½¿ç”¨ã€${data.card}ã€‘`;
        }
      });

      socket.on('nopePlayed', (data) => {
        if (!data) return;
        const actor = (data.id === socket.id) ? 'ä½ ' : 'å¯¹æ‰‹';
        lastActionMsg.value = `âœ‹ ${actor} æ‰“å‡ºäº†ã€é˜»æ­¢ã€‘ï¼ˆæ¬¡æ•°ï¼š${data.nopeCount}ï¼‰`;
      });

      socket.on('actionResolved', (data) => {
        if (!data) return;
        if (data.cancelled) lastActionMsg.value = `ğŸš« åŠ¨ä½œå¤±æ•ˆï¼š${data.reason || 'å·²è¢«é˜»æ­¢'}`;
        else lastActionMsg.value = `âœ… åŠ¨ä½œç”Ÿæ•ˆ`;
      });

      socket.on('gameOver', (data) => {
        applyEnded(data.winnerId);
      });

      socket.on('gameRestarted', () => {
        isGameOver.value = false;
        isWinner.value = false;
        winReasonText.value = '';

        amIDead.value = false;
        isDefusing.value = false;
        lastActionMsg.value = "=== æ–°æ¸¸æˆå¼€å§‹ ===";
        insertIndex.value = 0;
        topCardPublic.value = null;

        isPreviewing.value = false;
        previewCards.value = [];

        pendingAction.value = null;
        pendingMsLeft.value = 0;

        socket.emit('requestState');
      });

      socket.on('errorMsg', (data) => {
        if (data && data.message) lastActionMsg.value = "âš ï¸ " + data.message;
      });

      const isMyTurn = computed(() => {
        return phase.value === 'playing'
          && socket.id === currentTurnId.value
          && !amIDead.value;
      });

      const canPlayTurnCard = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && isMyTurn.value
          && !isDefusing.value
          && !pendingAction.value;
      });

      const canPlayNope = computed(() => {
        return phase.value === 'playing'
          && !isGameOver.value
          && !amIDead.value
          && !isDefusing.value
          && !!pendingAction.value
          && myHand.value.includes(nopeCard);
      });

      const pendingActionText = computed(() => {
        if (!pendingAction.value) return '';
        const pa = pendingAction.value;
        if (pa.displayCard === 'å…‹éš†ç‰Œ' && pa.clonedCard) return `å…‹éš†ç‰Œ â†’ ${pa.effectCard}`;
        return `${pa.displayCard}`;
      });

      function tickMsLeft() {
        if (!pendingAction.value || !pendingAction.value.resolveAt) {
          pendingMsLeft.value = 0;
          return;
        }
        const left = pendingAction.value.resolveAt - Date.now();
        pendingMsLeft.value = Math.max(0, Math.floor(left));
      }

      onMounted(() => {
        msTimer = setInterval(tickMsLeft, 100);
      });
      onUnmounted(() => {
        if (msTimer) clearInterval(msTimer);
      });

      const insertPositionText = computed(() => {
        const idx = parseInt(insertIndex.value);
        if (idx === deckMaxIndex.value) return "ç‰Œé¡¶ (æœ€å±é™©)";
        if (idx === 0) return "ç‰Œåº• (æœ€å®‰å…¨)";
        return `ç¬¬ ${idx + 1} å¼ `;
      });

      const drawCard = () => {
        if (phase.value !== 'playing') return;
        if (pendingAction.value) {
          lastActionMsg.value = "âš ï¸ æœ‰å¾…ç»“ç®—åŠ¨ä½œï¼Œå…ˆç­‰ç»“ç®—/ä½¿ç”¨é˜»æ­¢";
          return;
        }
        if (isMyTurn.value && !isDefusing.value) socket.emit('drawCard');
      };

      const onCardClick = (card) => {
        if (card === 'é˜»æ­¢') {
          if (!canPlayNope.value) {
            lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½ä½¿ç”¨é˜»æ­¢ï¼ˆæ— å¾…ç»“ç®—åŠ¨ä½œ/ä½ å·²æ­»äº¡/æ‹†å¼¹ä¸­ç­‰ï¼‰";
            return;
          }
          socket.emit('playNope');
          return;
        }

        if (!activeTurnCards.includes(card)) return;

        if (!canPlayTurnCard.value) {
          lastActionMsg.value = "âš ï¸ å½“å‰ä¸èƒ½å‡ºç‰Œï¼ˆéä½ å›åˆ/æ‹†å¼¹ä¸­/æœ‰å¾…ç»“ç®—åŠ¨ä½œ/å·²ç»“æŸï¼‰";
          return;
        }

        socket.emit('playCard', { card });
      };

      const isCardPlayable = (card) => {
        if (card === 'é˜»æ­¢') return canPlayNope.value;
        if (activeTurnCards.includes(card)) return canPlayTurnCard.value;
        return false;
      };

      const closePreview = () => {
        isPreviewing.value = false;
        previewCards.value = [];
      };

      const confirmInsert = () => {
        isDefusing.value = false;
        socket.emit('insertBomb', {
          index: parseInt(insertIndex.value),
          isPublic: isPublicInsert.value
        });
      };

      const requestRestart = () => {
        socket.emit('restartGame');
      };

      return {
        myHand, deckCount, currentTurnId, amIDead, lastActionMsg,
        phase,
        isDefusing, insertIndex, deckMaxIndex, insertPositionText, topCardPublic, isPublicInsert,
        isGameOver, isWinner, winReasonText,

        discardCount, discardTopCard, cardIcon,

        turnsLeftForCurrent,

        isPreviewing, previewCards, closePreview,

        pendingAction, pendingActionText, pendingMsLeft,

        isMyTurn,

        drawCard, onCardClick, isCardPlayable, cardHelp,

        confirmInsert, requestRestart
      };
    }
  }).mount('#app');
</script>
</body>
</html>
